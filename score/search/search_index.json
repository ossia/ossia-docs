{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Score documentation\n\n\nVersion 2.0.0.a4\n\n\nPresentation\n\n\nScore\n is an interactive sequencer for intermedia authoring. It allows to create flexible and interactive scenarios and is especially designed for live performance, art installations, museography or any context requiring a precise and interactive execution of timed events.\n\n\nScore\n brings timeline-based precise automation authoring as offerd in modern DAWs as well as flexible and interactive event triggering as offered in cue-based software in a unified environment. These two paradigms can be combined and used in parallel or hierarchically in \nScore\n's scenario, which provides a high level of control and of openness, as is required by today\u2019s creation.\n\n\n\n\nTable of content\n\n\nThis documentation will guide you through \nScore\n's workflow and advanced features.\n\n\nFirst steps\n\n\nThis section offers a general presentation of \nScore\n main concepts and workflow. It aims at guiding through the authoring of scenarios in \nScore\n.\n\n\nIntroduction\n\n\nTime approach in Score\n\n\nMeet the Score interface\n\n\nWriting your first scenario\n\n\nIn depth\n\n\nThis section offers advanced documentation on the various features offered in \nScore\n.\n\n\nProcesses\n\n\nAutomation Process\n\n\nInterpolation Process\n\n\nMapping Process\n\n\nLoop Process\n\n\nScenario Process\n\n\nHow tos ?\n\n\nThis section provides short technical highlights on different operations in \nScore\n application\n\n\nSetup\n\n\nSetup an OSC device\n\n\nManually declare a namespace\n\n\nUse the learn function\n\n\nEdit\n\n\nUpdate stored state\n\n\nFurther documentation\n\n\nSome informations may be missing from the documentation as new features get implemented in \nScore\n. Further assitance can be obtained from the \nOssia forum\n or by joining \nScore\n's \nGitter chat room", 
            "title": "Home"
        }, 
        {
            "location": "/index.html#score-documentation", 
            "text": "Version 2.0.0.a4", 
            "title": "Score documentation"
        }, 
        {
            "location": "/index.html#presentation", 
            "text": "Score  is an interactive sequencer for intermedia authoring. It allows to create flexible and interactive scenarios and is especially designed for live performance, art installations, museography or any context requiring a precise and interactive execution of timed events.  Score  brings timeline-based precise automation authoring as offerd in modern DAWs as well as flexible and interactive event triggering as offered in cue-based software in a unified environment. These two paradigms can be combined and used in parallel or hierarchically in  Score 's scenario, which provides a high level of control and of openness, as is required by today\u2019s creation.", 
            "title": "Presentation"
        }, 
        {
            "location": "/index.html#table-of-content", 
            "text": "This documentation will guide you through  Score 's workflow and advanced features.", 
            "title": "Table of content"
        }, 
        {
            "location": "/index.html#first-steps", 
            "text": "This section offers a general presentation of  Score  main concepts and workflow. It aims at guiding through the authoring of scenarios in  Score .", 
            "title": "First steps"
        }, 
        {
            "location": "/index.html#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#time-approach-in-score", 
            "text": "", 
            "title": "Time approach in Score"
        }, 
        {
            "location": "/index.html#meet-the-score-interface", 
            "text": "", 
            "title": "Meet the Score interface"
        }, 
        {
            "location": "/index.html#writing-your-first-scenario", 
            "text": "", 
            "title": "Writing your first scenario"
        }, 
        {
            "location": "/index.html#in-depth", 
            "text": "This section offers advanced documentation on the various features offered in  Score .", 
            "title": "In depth"
        }, 
        {
            "location": "/index.html#processes", 
            "text": "", 
            "title": "Processes"
        }, 
        {
            "location": "/index.html#automation-process", 
            "text": "", 
            "title": "Automation Process"
        }, 
        {
            "location": "/index.html#interpolation-process", 
            "text": "", 
            "title": "Interpolation Process"
        }, 
        {
            "location": "/index.html#mapping-process", 
            "text": "", 
            "title": "Mapping Process"
        }, 
        {
            "location": "/index.html#loop-process", 
            "text": "", 
            "title": "Loop Process"
        }, 
        {
            "location": "/index.html#scenario-process", 
            "text": "", 
            "title": "Scenario Process"
        }, 
        {
            "location": "/index.html#how-tos", 
            "text": "This section provides short technical highlights on different operations in  Score  application", 
            "title": "How tos ?"
        }, 
        {
            "location": "/index.html#setup", 
            "text": "", 
            "title": "Setup"
        }, 
        {
            "location": "/index.html#setup-an-osc-device", 
            "text": "", 
            "title": "Setup an OSC device"
        }, 
        {
            "location": "/index.html#manually-declare-a-namespace", 
            "text": "", 
            "title": "Manually declare a namespace"
        }, 
        {
            "location": "/index.html#use-the-learn-function", 
            "text": "", 
            "title": "Use the learn function"
        }, 
        {
            "location": "/index.html#edit", 
            "text": "", 
            "title": "Edit"
        }, 
        {
            "location": "/index.html#update-stored-state", 
            "text": "", 
            "title": "Update stored state"
        }, 
        {
            "location": "/index.html#further-documentation", 
            "text": "Some informations may be missing from the documentation as new features get implemented in  Score . Further assitance can be obtained from the  Ossia forum  or by joining  Score 's  Gitter chat room", 
            "title": "Further documentation"
        }, 
        {
            "location": "/first_steps/score-presentation/index.html", 
            "text": "Introduction\n\n\nScore\n is an interactive sequencer for intermedia authoring. It allows to create flexible and interactive scenarios and is especially designed for live performance, art installations, museography or any context requiring a precise and interactive execution of timed events.\n\n\nScore\n brings a flexible solution to the management and execution of events and their evolution in time. Modern DAWs now offer a number of tools to write precise automations along a timeline. However, as powerful as these are in the context of fixed-time media, such solutions are of little help when introducing interactivity in the execution of the produced scenarios. On the other hand, a number of software applications allow to trigger events in an interactive way, through a cue-based paradigm. However, these may not offer automation facilities as advanced as those found in modern DAW and also often rely on a sequential and linear triggering of events.\n\n\nScore\n brings these two approaches together in an unified timeline. Scenario authoring and execution in \nScore\n thus make it possible to write fixed-timed automations as well as interactive sequences of automations. Most importantly, these two paradigms can be combined and used in parallel or hierarchically, which provides a high level of control and of openness, as is required by today\u2019s creation.\n\n\n\n\nA sequencer for distributed media systems\n\n\nUnlike other digital multimedia workstations, \nScore\n does not aim at being an all-at-once software. Instead, it is designed to fully integrate with dedicated software and hardware one already uses in their own personal workflow. \n\n\nWhile recent versions of \nScore\n allow to process media (such as audio), it takes its root as a remote controller allowing to store \n recall snapshots and automations for some distant applications through various protocols (\nOSCQuery\n, \nOpen Sound Control\n, \nMidi\n or \nMinuit\n). Hence it can easily be used in large setups involving video, audio and/or light software or hardware, in order to provide a unified and global solution to control parameters changes in a synchronous or asynchronous way across diverse applications and domains.\n\n\n\n\nScore\n's features in a nutshell\n\n\nThis documentation will walk you through \nScore\n's basis concepts and advanced features to ease the mastering of its features.\n\n\n\n\nStore \n recall snapshots\n\n\nUse processes to write your application's parameters behaviour in time (BPF, interpolations, gradients)\n\n\nlinearly organize snapshots \n processes on the timeline\n\n\ntrigger events interactively\n\n\nloops \n\n\nbranching scenarios\n\n\n\n\nAnd more...", 
            "title": "Introduction"
        }, 
        {
            "location": "/first_steps/score-presentation/index.html#introduction", 
            "text": "Score  is an interactive sequencer for intermedia authoring. It allows to create flexible and interactive scenarios and is especially designed for live performance, art installations, museography or any context requiring a precise and interactive execution of timed events.  Score  brings a flexible solution to the management and execution of events and their evolution in time. Modern DAWs now offer a number of tools to write precise automations along a timeline. However, as powerful as these are in the context of fixed-time media, such solutions are of little help when introducing interactivity in the execution of the produced scenarios. On the other hand, a number of software applications allow to trigger events in an interactive way, through a cue-based paradigm. However, these may not offer automation facilities as advanced as those found in modern DAW and also often rely on a sequential and linear triggering of events.  Score  brings these two approaches together in an unified timeline. Scenario authoring and execution in  Score  thus make it possible to write fixed-timed automations as well as interactive sequences of automations. Most importantly, these two paradigms can be combined and used in parallel or hierarchically, which provides a high level of control and of openness, as is required by today\u2019s creation.", 
            "title": "Introduction"
        }, 
        {
            "location": "/first_steps/score-presentation/index.html#a-sequencer-for-distributed-media-systems", 
            "text": "Unlike other digital multimedia workstations,  Score  does not aim at being an all-at-once software. Instead, it is designed to fully integrate with dedicated software and hardware one already uses in their own personal workflow.   While recent versions of  Score  allow to process media (such as audio), it takes its root as a remote controller allowing to store   recall snapshots and automations for some distant applications through various protocols ( OSCQuery ,  Open Sound Control ,  Midi  or  Minuit ). Hence it can easily be used in large setups involving video, audio and/or light software or hardware, in order to provide a unified and global solution to control parameters changes in a synchronous or asynchronous way across diverse applications and domains.", 
            "title": "A sequencer for distributed media systems"
        }, 
        {
            "location": "/first_steps/score-presentation/index.html#scores-features-in-a-nutshell", 
            "text": "This documentation will walk you through  Score 's basis concepts and advanced features to ease the mastering of its features.   Store   recall snapshots  Use processes to write your application's parameters behaviour in time (BPF, interpolations, gradients)  linearly organize snapshots   processes on the timeline  trigger events interactively  loops   branching scenarios   And more...", 
            "title": "Score's features in a nutshell"
        }, 
        {
            "location": "/first_steps/time_approach/index.html", 
            "text": "Time approach in \nScore\n\n\nA number of features offered in \nScore\n (ie. snapshots, automations or interpolations) will most likely sound familiar to a number of users. However, as powerful and flexible the combination of fixed-time automations or interactive triggering of events is, it may be helpful to get a clear understanding of the time model that drove \nScore\n\u2019s conception and the design of its workflow.\n\n\nA useful metaphor to understand how time is managed in \nScore\n can be to envision \ntime as a stream flowing through the scenario written on the timeline\n. Following this metaphor, \nScore\n thus provides a number of tools to author complex scenarios : Various paths (through which time will flow) can be defined on the timeline. Events (snapshots or timed processes) can then be attached to those paths: they will execute as time crosses them by. Finally, gates can be inserted, that will get opened or closed in various ways (interactive triggering, branchings).\n\n\nLet the time flow\n\n\nWhen opening \nScore\n, user gets provided a blank scenario and its default time source. When clicking the play button (or pressing \nspacebar\n key), time will start flowing along the top timeline. You can see below the green progress bar advancing along the top ruler displaying time in minutes:seconds.milliseconds. Plain and simple.\n\n\n\n\nRather than providing predefined tracks for example, \nScore\n allows to organize your distant application's parameters\u2019 behavior on the timeline in flexible ways. Depending on your needs or workflow, you may write different paths by inserting  some events on the timeline, and linking them using intervals (ie. having paths dedicated to the control of particular devices, or dedicating different paths to different rooms of an installation).\n\n\nWhen playing your scenario, you will see that \ntime flows through the various paths\n as their progress bar moves forward.\n\n\n\n\n\n\nNote how important it is that all the event paths are connected to the beginning of your scenario so they get executed following the timeline. You may think of these intervals between events as \nfeeder pipes\n. They ensure that time will spread from the beginning of your scenario to the first attached event, then to the next one and so one. On the contrary, any event not connected to the beginning of your scenario or to another event will not get provided a time source: they will not get executed as time passes by.\n\n\n\n\nOpen the floodgate !\n\n\nOne of \nScore\n's strength is the introduction of the time flexibility usually found in cue-based softwares with a timeline approach. \nScore\n hence provides two different ways to do this: by breaking or putting on hold the time-flow in a chosen path of a scenario ; or by writing several versions of a path to be chosen during the execution of your scenario. \n\n\nThe first way to introduce temporal flexibility is to add a \ntrigger\n to an event in your scenario. As time reaches this event, execution is put on hold until event is triggered, be it from a mouse click or when a particular value is sent or queried from a remote software or sensor. Following our time-flow metaphor, when done so, the \nfloodgate will open\n and time will continue to flow down the path. Adjacent paths that are not set with a trigger will follow the general time flow independently.\n\n\n\n\nThe second way to introduce temporal flexibility is to set \nconditions\n on events (ie. if the value of a remote parameter such as the distance between an user and a sensor is either above or beyond a particular threshold). When time reaches these conditional events, \nScore\n will check which conditions are true and will choose which path(s) to execute. \n\n\n\n\nOf course as detailed later in this documentation, both interactive triggering and conditional execution can be used along with other features so you can get a precise control of time flow in your scenario.\n\n\nHierarchical/cascading time flow\n\n\nUsing intervals between events in your scenario ensures that time will flow along the paths and will trigger events or automations as they are reached. Yet another feature allows you to add even more temporal flexibility, by precisely and continuously controlling the speed of the time-flow, in a hierarchical and cascading way. \n\n\n\n\nEach interval in a \nScore\n scenario provides a speed control allowing to adjust how time will travel along the paths during the execution of your scenario. This makes a very useful feature, in particular for live performance when you may want to slow down a particular process (ie. light automation) a bit as the performer on stage takes more time to reach his new position, while not affecting automations controlling another process (e.g. sound spatialization). \n\n\n\n\nBut the important point to note here is that changing the speed of a given interval will also affect the sub-paths it is feeding time to, in a \ncascading way\n. You may think of this speed variable as an \nadjustable tap at each feeder pipe input\n. For example, when using sub-scenarios, changing the speed of the parent interval will propagate to the whole scenario it holds. On the other hand, changing the speed of an interval inside the sub-scenario will only affect this interval and its attached processes while the parent interval time will progress as written in the scenario.\n\n\n\n\nOut of time events\n\n\nAs explained above, events must be connected to a time source to be executed as time progresses. When placed in \nScore\n\u2019s timeline without being connected to a preceding interval, events are what we call \ndetached from the timeline\n and their execution does not follow its progression. \n\n\nThis can be extremely useful when you want to freely send parameters value or automation at any time in the execution of you scenario. \n\n\n\n\nNote that these \ndetached events\n then provide a time source and following events or automations will get executed as time progresses from this initial event. Also, in contrast to other usual scenario elements, detached events and event-interval compounds can be triggered repeatedly.", 
            "title": "Time approach in Score"
        }, 
        {
            "location": "/first_steps/time_approach/index.html#time-approach-in-score", 
            "text": "A number of features offered in  Score  (ie. snapshots, automations or interpolations) will most likely sound familiar to a number of users. However, as powerful and flexible the combination of fixed-time automations or interactive triggering of events is, it may be helpful to get a clear understanding of the time model that drove  Score \u2019s conception and the design of its workflow.  A useful metaphor to understand how time is managed in  Score  can be to envision  time as a stream flowing through the scenario written on the timeline . Following this metaphor,  Score  thus provides a number of tools to author complex scenarios : Various paths (through which time will flow) can be defined on the timeline. Events (snapshots or timed processes) can then be attached to those paths: they will execute as time crosses them by. Finally, gates can be inserted, that will get opened or closed in various ways (interactive triggering, branchings).", 
            "title": "Time approach in Score"
        }, 
        {
            "location": "/first_steps/time_approach/index.html#let-the-time-flow", 
            "text": "When opening  Score , user gets provided a blank scenario and its default time source. When clicking the play button (or pressing  spacebar  key), time will start flowing along the top timeline. You can see below the green progress bar advancing along the top ruler displaying time in minutes:seconds.milliseconds. Plain and simple.   Rather than providing predefined tracks for example,  Score  allows to organize your distant application's parameters\u2019 behavior on the timeline in flexible ways. Depending on your needs or workflow, you may write different paths by inserting  some events on the timeline, and linking them using intervals (ie. having paths dedicated to the control of particular devices, or dedicating different paths to different rooms of an installation).  When playing your scenario, you will see that  time flows through the various paths  as their progress bar moves forward.    Note how important it is that all the event paths are connected to the beginning of your scenario so they get executed following the timeline. You may think of these intervals between events as  feeder pipes . They ensure that time will spread from the beginning of your scenario to the first attached event, then to the next one and so one. On the contrary, any event not connected to the beginning of your scenario or to another event will not get provided a time source: they will not get executed as time passes by.", 
            "title": "Let the time flow"
        }, 
        {
            "location": "/first_steps/time_approach/index.html#open-the-floodgate", 
            "text": "One of  Score 's strength is the introduction of the time flexibility usually found in cue-based softwares with a timeline approach.  Score  hence provides two different ways to do this: by breaking or putting on hold the time-flow in a chosen path of a scenario ; or by writing several versions of a path to be chosen during the execution of your scenario.   The first way to introduce temporal flexibility is to add a  trigger  to an event in your scenario. As time reaches this event, execution is put on hold until event is triggered, be it from a mouse click or when a particular value is sent or queried from a remote software or sensor. Following our time-flow metaphor, when done so, the  floodgate will open  and time will continue to flow down the path. Adjacent paths that are not set with a trigger will follow the general time flow independently.   The second way to introduce temporal flexibility is to set  conditions  on events (ie. if the value of a remote parameter such as the distance between an user and a sensor is either above or beyond a particular threshold). When time reaches these conditional events,  Score  will check which conditions are true and will choose which path(s) to execute.    Of course as detailed later in this documentation, both interactive triggering and conditional execution can be used along with other features so you can get a precise control of time flow in your scenario.", 
            "title": "Open the floodgate !"
        }, 
        {
            "location": "/first_steps/time_approach/index.html#hierarchicalcascading-time-flow", 
            "text": "Using intervals between events in your scenario ensures that time will flow along the paths and will trigger events or automations as they are reached. Yet another feature allows you to add even more temporal flexibility, by precisely and continuously controlling the speed of the time-flow, in a hierarchical and cascading way.    Each interval in a  Score  scenario provides a speed control allowing to adjust how time will travel along the paths during the execution of your scenario. This makes a very useful feature, in particular for live performance when you may want to slow down a particular process (ie. light automation) a bit as the performer on stage takes more time to reach his new position, while not affecting automations controlling another process (e.g. sound spatialization).    But the important point to note here is that changing the speed of a given interval will also affect the sub-paths it is feeding time to, in a  cascading way . You may think of this speed variable as an  adjustable tap at each feeder pipe input . For example, when using sub-scenarios, changing the speed of the parent interval will propagate to the whole scenario it holds. On the other hand, changing the speed of an interval inside the sub-scenario will only affect this interval and its attached processes while the parent interval time will progress as written in the scenario.", 
            "title": "Hierarchical/cascading time flow"
        }, 
        {
            "location": "/first_steps/time_approach/index.html#out-of-time-events", 
            "text": "As explained above, events must be connected to a time source to be executed as time progresses. When placed in  Score \u2019s timeline without being connected to a preceding interval, events are what we call  detached from the timeline  and their execution does not follow its progression.   This can be extremely useful when you want to freely send parameters value or automation at any time in the execution of you scenario.    Note that these  detached events  then provide a time source and following events or automations will get executed as time progresses from this initial event. Also, in contrast to other usual scenario elements, detached events and event-interval compounds can be triggered repeatedly.", 
            "title": "Out of time events"
        }, 
        {
            "location": "/first_steps/meet_score_interface/index.html", 
            "text": "Meet the Score interface\n\n\nHere we will go through the various parts of Score's interface. Rather than going into each detail or advanced feature, we will first do a short run through of Score environment so you can feel at ease when going into deeper in the following tutorials.\n\n\nAs an example, we use here the demo scenario provided in the \nOverview\n folder. Feel free to open this scenario in Score as we explore core parts of the GUI as well as read the numerous comments added to it.\n\n\n\n\nOnce opened, Score provides a unique window embedding all main features and toolboxes. From it, you will be able to setup how your media applications and Score will communicate, observe their parameters value navigate through their namespace in a structured way, store some parameters value in snapshots, draw some automations, structure you scenario in flexible ways, etc. All can be done from one of the 3 UI areas:\n\n\n\n\nthe Device explorer\n\n\nScore's timeline\n\n\nobjects inspector\n\n\n\n\n\n\nNote that all main parts of Score GUI are dockable. Hence you may move them appart from main window using the button at the top right or by click+drag on their top bar. You can add them back by closing the detached window and toggling it back on in the \nView \n Windows\n menu or use the \nView \n Restore layout\n menu entry.\n\n\n\n\n\n\nDevice explorer\n\n\n\n\nFirst pane on the left of Score window is the \nDevice explorer\n pane. As its name implies, this is where you can observe the state of the devices you want to control from your Score scenario. These devices may be media applications of pieces of hardware used in your project.\n\n\nDevices are presented in the \nDevice explorer\n as a tree-like list of all parameters declared in your application (the application namespace). Using our overview.scorejson demo file, you can see two devices here are declared: a dummy OSCdevice (that can be used with one of the provided Max/Pd patches, Processing sketch or Unity project) and Score itself (so it can be controlled from the scenario). Clicking one of the triangle widgets sitting next to the devices name unfolds the list of parameters declared in the controlled applications. Subsequently, each node can be fold/unfold to display or hide its child parameters. Clicking on an address node in the Device explorer also brings a handy inspector displaying the various attributes of this node (ie. Full address, value range, optional associated tags).\n\n\nAll parameters in your devices namespace display their current value in the Device explorer right column (assuming your device provides some mechanisms to echo back parameters state). You may even send some new value for a parameter by double-clicking and typing a new value in its value textfield. The Device explorer also provides an easy way to select some parameters from the namespace by clicking on a parameter name (or a range of addresses using shift + click or any addresses using cmd + click / ctrl + click) and drag them on the Timeline. Spoiler alert: you just created a snapshot in your scenario !\n\n\nScore Timeline\n\n\nAt the centre of the window is Score's Timeline. This is where you will actually write the scenario handling the commands sent to your devices as well as do some audio synthesis or processing and their organisation in time.\n\n\n\n\nWithout going into details in this chapter (following chapters will do so), as seen in the overview.scorejson file example, commands or processes sent to your devices are organized in time using a set of elementary objects:\n\n\n\n\nevents: little blue dots with optional list of parameters values attached to it (white circle that is framing it)\n\n\nintervals: the horizontal blue lines connecting events that will stream time along the timeline\n\n\nprocesses: containers attached to an interval allowing some processes (ie. automation, mapping, custom js scripts) to operate over a dedicated time length\n\n\n\n\nAgain, following chapters in the documentation will go through each of these and their various toolboxes available. \n\n\nScore timeline also offers a synthetic view of the whole scenario at the top of the pane. From it you can zoom in/out in your scenario using \nclick + drag up/down\n or navigate in your scenario using \nclick + drag left/right\n.\n\n\n\n\nObject inspector\n\n\nLast core element of Score window is the objects inspector. This area actually provides two inspectors\n\n\n\n\nThe object inspector allowing to explore \n select elements in your scenario structure (ie. events, intervals, trigger)\n\n\nThe inspector allowing to display and edit parameters of the currently selected object (ie. state or process)\n\n\n\n\n\n\nThe object inspector at the top allows to select an object and see its hierarchical context. In the screen capture below, you will first see we can select each of the four events by selecting the sync bar connecting them, or display the processes attached to their parent interval.\n\n\nYou may also navigate through the structure of your scenario backward/forward or hierarchically using the four arrows above the list of objects as well as navigate through the history of recently selected objects.\n\n\n\n\nThe inspector below, allows to edit the various options of an object (ie. An event position on the timeline or an interval duration) and edit their attached content (ie. Addresses and values stored in a snapshot, automation's range or destination).\n\n\n\n\nOf course, actual option fields of the Inspector are dynamic and depend on which object is currently selected. These options will get detailed in the following chapters of the documentation.\n\n\nIn the mean time, this should get us basis information to get us started writing our first scenario.", 
            "title": "Meet the Score interface"
        }, 
        {
            "location": "/first_steps/meet_score_interface/index.html#meet-the-score-interface", 
            "text": "Here we will go through the various parts of Score's interface. Rather than going into each detail or advanced feature, we will first do a short run through of Score environment so you can feel at ease when going into deeper in the following tutorials.  As an example, we use here the demo scenario provided in the  Overview  folder. Feel free to open this scenario in Score as we explore core parts of the GUI as well as read the numerous comments added to it.   Once opened, Score provides a unique window embedding all main features and toolboxes. From it, you will be able to setup how your media applications and Score will communicate, observe their parameters value navigate through their namespace in a structured way, store some parameters value in snapshots, draw some automations, structure you scenario in flexible ways, etc. All can be done from one of the 3 UI areas:   the Device explorer  Score's timeline  objects inspector    Note that all main parts of Score GUI are dockable. Hence you may move them appart from main window using the button at the top right or by click+drag on their top bar. You can add them back by closing the detached window and toggling it back on in the  View   Windows  menu or use the  View   Restore layout  menu entry.", 
            "title": "Meet the Score interface"
        }, 
        {
            "location": "/first_steps/meet_score_interface/index.html#device-explorer", 
            "text": "First pane on the left of Score window is the  Device explorer  pane. As its name implies, this is where you can observe the state of the devices you want to control from your Score scenario. These devices may be media applications of pieces of hardware used in your project.  Devices are presented in the  Device explorer  as a tree-like list of all parameters declared in your application (the application namespace). Using our overview.scorejson demo file, you can see two devices here are declared: a dummy OSCdevice (that can be used with one of the provided Max/Pd patches, Processing sketch or Unity project) and Score itself (so it can be controlled from the scenario). Clicking one of the triangle widgets sitting next to the devices name unfolds the list of parameters declared in the controlled applications. Subsequently, each node can be fold/unfold to display or hide its child parameters. Clicking on an address node in the Device explorer also brings a handy inspector displaying the various attributes of this node (ie. Full address, value range, optional associated tags).  All parameters in your devices namespace display their current value in the Device explorer right column (assuming your device provides some mechanisms to echo back parameters state). You may even send some new value for a parameter by double-clicking and typing a new value in its value textfield. The Device explorer also provides an easy way to select some parameters from the namespace by clicking on a parameter name (or a range of addresses using shift + click or any addresses using cmd + click / ctrl + click) and drag them on the Timeline. Spoiler alert: you just created a snapshot in your scenario !", 
            "title": "Device explorer"
        }, 
        {
            "location": "/first_steps/meet_score_interface/index.html#score-timeline", 
            "text": "At the centre of the window is Score's Timeline. This is where you will actually write the scenario handling the commands sent to your devices as well as do some audio synthesis or processing and their organisation in time.   Without going into details in this chapter (following chapters will do so), as seen in the overview.scorejson file example, commands or processes sent to your devices are organized in time using a set of elementary objects:   events: little blue dots with optional list of parameters values attached to it (white circle that is framing it)  intervals: the horizontal blue lines connecting events that will stream time along the timeline  processes: containers attached to an interval allowing some processes (ie. automation, mapping, custom js scripts) to operate over a dedicated time length   Again, following chapters in the documentation will go through each of these and their various toolboxes available.   Score timeline also offers a synthetic view of the whole scenario at the top of the pane. From it you can zoom in/out in your scenario using  click + drag up/down  or navigate in your scenario using  click + drag left/right .", 
            "title": "Score Timeline"
        }, 
        {
            "location": "/first_steps/meet_score_interface/index.html#object-inspector", 
            "text": "Last core element of Score window is the objects inspector. This area actually provides two inspectors   The object inspector allowing to explore   select elements in your scenario structure (ie. events, intervals, trigger)  The inspector allowing to display and edit parameters of the currently selected object (ie. state or process)    The object inspector at the top allows to select an object and see its hierarchical context. In the screen capture below, you will first see we can select each of the four events by selecting the sync bar connecting them, or display the processes attached to their parent interval.  You may also navigate through the structure of your scenario backward/forward or hierarchically using the four arrows above the list of objects as well as navigate through the history of recently selected objects.   The inspector below, allows to edit the various options of an object (ie. An event position on the timeline or an interval duration) and edit their attached content (ie. Addresses and values stored in a snapshot, automation's range or destination).   Of course, actual option fields of the Inspector are dynamic and depend on which object is currently selected. These options will get detailed in the following chapters of the documentation.  In the mean time, this should get us basis information to get us started writing our first scenario.", 
            "title": "Object inspector"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html", 
            "text": "Writing your first Score scenario\n\n\nIn this short tutorial, we will write a simple scenario in Score. This should provide the basis to get familiar with Score interface and general workflow.\n\n\nHere we will use a simple frequency modulation-based synthesizer provided with Score documentation. Assuming you already have Pd or Max installed on you computer, you may use the Pd or Max version of this patch.\n\n\n\n\nIf frequency modulation synthesis does not sounds like fun to you, you may follow this tutorial using your favorite Open Sound Control (OSC) application. In that case, just follow the various steps and adjust the various options (OSC configuration, namespace configuration, etc.) to your application.\n\n\n\n\nSince we will use Score to control a distant application, we first need to setup our OSC device in Score so they can communicate properly.\n\n\nAdding your device\n\n\nOnce launched, Score opens with an empty window. To setup our OSC device, click the \n+\n button at the bottom left of the \nDevice explorer\n pane or use \ncmd + B\n (on MacOS) / \nctrl + B\n (on Windows) shortcut. This prompts a configuration window where we can setup various protocols informations.\n\n\n\n\nThe configuration window provides a list of all protocols supported in Score. Here we will select OSC from the menu. This bring the various option fields needed to setup the communication between our application and Score:\n\n\n\n\nA name for the device (used for display only)\n\n\nThe network port your application will receive OSC messages from\n\n\nThe network port Score will receive OSC messages from (assuming your application can echo back its parameters current state)\n\n\nIP address of the computer of your application is running on.\n\n\n\n\nOur simple patch example is built to use Score's OSC default ports and address so you can leave the above fields untouched. Then click the \nload\n button to load the \nfm-osc-example.device\n namespace file of our device. Press the \nreturn\n key or click the \nOK\n button. The Device explorer should now display our device named \nOSCdevice\n along with all its parameters and various attributes settings in a tree-like view.\n\n\n\n\nShould you need to modify the OSC setup of your device, right-click on your device name in the Device explorer pane and choose \nEdit\n.\n\n\n\n\nThe namespace file we just loaded is a json file describing all parameters addresses of a device we want to send values to. If using another OSC application for this tutorial, you may either use the learn feature available when right-clicking your device name in the Device explorer, or manually declare the namespace of your application. In the later case, please see the \nHow to manually declare a namespace\n documentation page.\n\n\n\n\nSetting an initial state\n\n\nWe will start by setting an \ninit\n state for our scenario. In this case, the default state of our device will be perfect as an init state so we will just store its parameters current value in the scenario initial event.\n\n\nThe easiest way to do this is to select the parameter to store from the Device explorer pane then drag them on the scenario initial event. Selection can be done using regular mouse \n key combos. Hence we can select the 'pan' parameter then \nshift + click\n on the 'frequency' parameter to select both these addresses and all between them in the tree view. For the sake of this tutorial, we will also make sure that DSP processing is turned off by default in Pd. With the current selected addresses, cmd + click (on MacOS) or ctrl + click (on Windows) on the 'stop' parameter then drag this full selection on the initial event as shown below. \n\n\n\n\nNote that selecting a node containing parameters in the namespace will select all parameters below it (ie. clicking 'modulation' selects both 'modulation/index' \n 'modulation/ratio')\n\n\n\n\n\n\nWhen done, you can see that the scenario initial event (the blue dot on the scenario timeline) is now displayed with a surrounding white circle. If you click on the state we just created, you can see in the inspector all the stored values and their associated value.\n\n\n\n\nHaving set this init state, now when reinitializing the scenario (using \ncmd + return\n on macOS or \nctrl + return\n on Windows), Score will automatically recall our device's state so it is ready to go !\n\n\n\n\nStoring states of your device\n\n\nWe will now store more states in our scenario and organize them on the timeline.\n\n\nWe will start with a simple state used to turn Pd's DSP processing on. As we previously did, let's grab the 'start' parameter and drop it on Score timeline. As you are hovering the timeline with the 'start' parameter, notice that a grey dashed line connected to the first event on the scenario is drawn. \nRemember that events and processes needed to connected to a time source\n so they get properly executed as time progress in the scenario. By default, Score then offers to automatically connect events sequentially.\n\n\n\n\nAgain, if you select the created state, you can see in its inspector that the 'start' parameter has been saved.\n\n\nYou can select this event and move it around on the timeline. Moving it horizontally lets you adjust its position on the timeline (hence when the stored parameters will get sent when playing the scenario). Vertical position has no but graphical purpose for the execution of our scenario. We can now store more states.\n\n\nThe device used in this tutorial only provides unidirectional communication (our device can only receive message from Score) so we will use the device explorer as a simple remote interface. To do so, just double-click on the value fields you want to change and type the desired value. We will for example raise the gain up to 0 dB, set the 'modulation/index' to 100 and set the 'ramptime' to 20 ms.You may now store this new state just as we did above.\n\n\n\n\nWhen using bidirectional protocol between Score and your device (ie. OSCquery), Score will listen to the parameters changes in the device. You may then make changes right from your device or using your favorites controllers (hence avoid fastidiously typing values by hand)\n\n\n\n\nSelect the addresses you want to store then drag them on the timeline. You will see that Score offers to connect this new event to the event it is most aligned with. Make sure to connect this new event to the one we previously created.\n\n\nNow follow your inspiration and store on the timeline as many of your device's states or \nfine tune them\n as you wish. \n\n\nPress the \nspacebar\n to start playing our scenario and recalling these snapshots as time moves along the timeline. You may pause the execution of our scenario pressing the \nspacebar\n again or stop it using \nreturn\n key (remember of can use \ncmd + return\n or \nctrl + return\n to stop and fully reinitialize the scenario).\n\n\nAdjusting events in time\n\n\nWe saw that moving events along allows to adjust events' position on the timeline. But a few important points are worth to be added to the topic. One of Score's strength resides in some advanced features to control time flow in a highly precise way. This is especially useful as your scenario grows and as the various media dealt with your device (sound generation or processing, video, lights) induces complex temporal relationship between events.\n\n\nIf you select the last state you stored in your scenario, you can move it on the timeline as previously done. Now select a state in the middle of a sequence of events and see what happens: Score will preserve the length of the interval to the following event and \nmove\n all following events in your scenario subsequently. This is extremely useful when wanting to adjusting things locally (ie. Parts of a scene of a theatre piece while rehearsing ) while maintaining the rest of the structure untouched.\n\n\n\n\nYou may also adjust time between events with a particular length (ie. The time it takes for some curtains to get drawn on stage). To do so, select an interval by clicking on it in the timeline, then from its inspector, type the desired length.\n\n\n\n\nThere are some times when you may want to move some event without moving all following events, though. This can be done by moving things around using the \nlock mode\n. To do so, click on the lock button in the toolbar and move the selected event on the timeline (or select an event to move while holding the \noption\n key on macOS or \nalt\n key on Windows).\n\n\n\n\nWriting processes\n\n\nNow that we covered the basis of Score workflow, we may add a little more animation to our scenario using a few of the many processes provided in Score.\n\n\nProcesses are different widgets allowing to control some parameter's value over a given amount of time (the length given by an interval drawn in the scenario). Let start by adding a gentle fade in in our scenario. To do so, we will add an automation on our 'gain' parameter. From the Device explorer, select the 'gain' parameter and let's drag \n drop it over the interval linking the first and second states on the timeline (that is, the one containing the 'start' message and the one raising the 'gain' to 0 dB , etc.). Score automatically creates a break-point function automation.\n\n\n\n\nYou may fine-tune your break-point function and more points by double-clicking in the automation background, move points by selecting points then move them around or add curve using \nshift + drag\n on a segment.\n\n\nThere are various types of functions for the automation process. We will add a little more fun to our scenario using another one of these.\n\n\nIn this second example, we want to create an automation following the last state of our device that we store in the scenario. Since there is no interval already in place, we first need to create one so we can attach a process to it. To do so, select the last stored state in our scenario. You can see that a little yellow '+' sign popup next to the event. \nclick + drag\n on the plus sign to draw an interval in the scenario of a desired length, then release your mouse. We thus created an interval (without storing state at its right end).\n\n\n\n\nWe may now drag the parameter to automate as we previously did. Although, while dragging and dropping parameters is a handy shortcut, there are situations (when using generator processes) where we cannot benefit from these so we will go through the whole process by hand.\n\n\nClick on the interval we just created to bring a little '+' sign attached to the interval. Click that '+' sign to open up the processes library. The window displays different banks each containing various processes. From the 'automations' bank, choose 'automation (float)'. Double-click (or click the '+' button) then close the window. We now created an automation.\n\n\n\n\nWe first have to set the name of the parameter we want to automate. Click on the automation header (displaying \"Automation\" as a greyed out label) to bring its inspector. From the Device explorer, select the parameter to automate (ie 'modulation/ratio') and drag it over to 'Address' field the automation inspector. The automation will now use this parameter as destination. \n\n\nThe automation process offers a number of embedded function (standard easing functions, waveforms, etc.). Hence, rather than adding points and curve, here we will use the noise generator. In the automation box, select the red segment then right-click. From the function contextual menu, navigate through the 'Automation (float) \n Type' section then choose 'noise'. Score now filled our automation process with a random function.\n\n\n\n\nOne more thing we may want to do before listening to our composition. When doing automation, Score use by default the min/max values of the automated parameter. Here, we will adjust these bounds so the automation runs in a user-defined range.\n\n\nFrom the automation inspector, check the min and max textfield and set desired values. We will arbitrary use a minimum value of 5 and maximum value of 9. But feel free to experiment and adjust to your taste!\n\n\nSummary\n\n\nWe now covered the major features of the Score workflow: setting up your devices network, storing \n recalling snapshots, writing automations for the parameters of your device, write precise temporal structure.\n\n\nScore offers a number of other features depending on the protocols used to communicate with your devices, handy shortcuts to ease the writing of complex performances or installations, vast collection of available processes that will get covered in the following on the documentation.\n\n\nIn the mean time, this should get you the needed basis to start with Score scenario authoring.\n\n\nYou may now sit comfortably, relax and enjoy your composition. Or just start experimenting !", 
            "title": "Writing your first scenario"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#writing-your-first-score-scenario", 
            "text": "In this short tutorial, we will write a simple scenario in Score. This should provide the basis to get familiar with Score interface and general workflow.  Here we will use a simple frequency modulation-based synthesizer provided with Score documentation. Assuming you already have Pd or Max installed on you computer, you may use the Pd or Max version of this patch.   If frequency modulation synthesis does not sounds like fun to you, you may follow this tutorial using your favorite Open Sound Control (OSC) application. In that case, just follow the various steps and adjust the various options (OSC configuration, namespace configuration, etc.) to your application.   Since we will use Score to control a distant application, we first need to setup our OSC device in Score so they can communicate properly.", 
            "title": "Writing your first Score scenario"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#adding-your-device", 
            "text": "Once launched, Score opens with an empty window. To setup our OSC device, click the  +  button at the bottom left of the  Device explorer  pane or use  cmd + B  (on MacOS) /  ctrl + B  (on Windows) shortcut. This prompts a configuration window where we can setup various protocols informations.   The configuration window provides a list of all protocols supported in Score. Here we will select OSC from the menu. This bring the various option fields needed to setup the communication between our application and Score:   A name for the device (used for display only)  The network port your application will receive OSC messages from  The network port Score will receive OSC messages from (assuming your application can echo back its parameters current state)  IP address of the computer of your application is running on.   Our simple patch example is built to use Score's OSC default ports and address so you can leave the above fields untouched. Then click the  load  button to load the  fm-osc-example.device  namespace file of our device. Press the  return  key or click the  OK  button. The Device explorer should now display our device named  OSCdevice  along with all its parameters and various attributes settings in a tree-like view.   Should you need to modify the OSC setup of your device, right-click on your device name in the Device explorer pane and choose  Edit .   The namespace file we just loaded is a json file describing all parameters addresses of a device we want to send values to. If using another OSC application for this tutorial, you may either use the learn feature available when right-clicking your device name in the Device explorer, or manually declare the namespace of your application. In the later case, please see the  How to manually declare a namespace  documentation page.", 
            "title": "Adding your device"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#setting-an-initial-state", 
            "text": "We will start by setting an  init  state for our scenario. In this case, the default state of our device will be perfect as an init state so we will just store its parameters current value in the scenario initial event.  The easiest way to do this is to select the parameter to store from the Device explorer pane then drag them on the scenario initial event. Selection can be done using regular mouse   key combos. Hence we can select the 'pan' parameter then  shift + click  on the 'frequency' parameter to select both these addresses and all between them in the tree view. For the sake of this tutorial, we will also make sure that DSP processing is turned off by default in Pd. With the current selected addresses, cmd + click (on MacOS) or ctrl + click (on Windows) on the 'stop' parameter then drag this full selection on the initial event as shown below.    Note that selecting a node containing parameters in the namespace will select all parameters below it (ie. clicking 'modulation' selects both 'modulation/index'   'modulation/ratio')    When done, you can see that the scenario initial event (the blue dot on the scenario timeline) is now displayed with a surrounding white circle. If you click on the state we just created, you can see in the inspector all the stored values and their associated value.   Having set this init state, now when reinitializing the scenario (using  cmd + return  on macOS or  ctrl + return  on Windows), Score will automatically recall our device's state so it is ready to go !", 
            "title": "Setting an initial state"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#storing-states-of-your-device", 
            "text": "We will now store more states in our scenario and organize them on the timeline.  We will start with a simple state used to turn Pd's DSP processing on. As we previously did, let's grab the 'start' parameter and drop it on Score timeline. As you are hovering the timeline with the 'start' parameter, notice that a grey dashed line connected to the first event on the scenario is drawn.  Remember that events and processes needed to connected to a time source  so they get properly executed as time progress in the scenario. By default, Score then offers to automatically connect events sequentially.   Again, if you select the created state, you can see in its inspector that the 'start' parameter has been saved.  You can select this event and move it around on the timeline. Moving it horizontally lets you adjust its position on the timeline (hence when the stored parameters will get sent when playing the scenario). Vertical position has no but graphical purpose for the execution of our scenario. We can now store more states.  The device used in this tutorial only provides unidirectional communication (our device can only receive message from Score) so we will use the device explorer as a simple remote interface. To do so, just double-click on the value fields you want to change and type the desired value. We will for example raise the gain up to 0 dB, set the 'modulation/index' to 100 and set the 'ramptime' to 20 ms.You may now store this new state just as we did above.   When using bidirectional protocol between Score and your device (ie. OSCquery), Score will listen to the parameters changes in the device. You may then make changes right from your device or using your favorites controllers (hence avoid fastidiously typing values by hand)   Select the addresses you want to store then drag them on the timeline. You will see that Score offers to connect this new event to the event it is most aligned with. Make sure to connect this new event to the one we previously created.  Now follow your inspiration and store on the timeline as many of your device's states or  fine tune them  as you wish.   Press the  spacebar  to start playing our scenario and recalling these snapshots as time moves along the timeline. You may pause the execution of our scenario pressing the  spacebar  again or stop it using  return  key (remember of can use  cmd + return  or  ctrl + return  to stop and fully reinitialize the scenario).", 
            "title": "Storing states of your device"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#adjusting-events-in-time", 
            "text": "We saw that moving events along allows to adjust events' position on the timeline. But a few important points are worth to be added to the topic. One of Score's strength resides in some advanced features to control time flow in a highly precise way. This is especially useful as your scenario grows and as the various media dealt with your device (sound generation or processing, video, lights) induces complex temporal relationship between events.  If you select the last state you stored in your scenario, you can move it on the timeline as previously done. Now select a state in the middle of a sequence of events and see what happens: Score will preserve the length of the interval to the following event and  move  all following events in your scenario subsequently. This is extremely useful when wanting to adjusting things locally (ie. Parts of a scene of a theatre piece while rehearsing ) while maintaining the rest of the structure untouched.   You may also adjust time between events with a particular length (ie. The time it takes for some curtains to get drawn on stage). To do so, select an interval by clicking on it in the timeline, then from its inspector, type the desired length.   There are some times when you may want to move some event without moving all following events, though. This can be done by moving things around using the  lock mode . To do so, click on the lock button in the toolbar and move the selected event on the timeline (or select an event to move while holding the  option  key on macOS or  alt  key on Windows).", 
            "title": "Adjusting events in time"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#writing-processes", 
            "text": "Now that we covered the basis of Score workflow, we may add a little more animation to our scenario using a few of the many processes provided in Score.  Processes are different widgets allowing to control some parameter's value over a given amount of time (the length given by an interval drawn in the scenario). Let start by adding a gentle fade in in our scenario. To do so, we will add an automation on our 'gain' parameter. From the Device explorer, select the 'gain' parameter and let's drag   drop it over the interval linking the first and second states on the timeline (that is, the one containing the 'start' message and the one raising the 'gain' to 0 dB , etc.). Score automatically creates a break-point function automation.   You may fine-tune your break-point function and more points by double-clicking in the automation background, move points by selecting points then move them around or add curve using  shift + drag  on a segment.  There are various types of functions for the automation process. We will add a little more fun to our scenario using another one of these.  In this second example, we want to create an automation following the last state of our device that we store in the scenario. Since there is no interval already in place, we first need to create one so we can attach a process to it. To do so, select the last stored state in our scenario. You can see that a little yellow '+' sign popup next to the event.  click + drag  on the plus sign to draw an interval in the scenario of a desired length, then release your mouse. We thus created an interval (without storing state at its right end).   We may now drag the parameter to automate as we previously did. Although, while dragging and dropping parameters is a handy shortcut, there are situations (when using generator processes) where we cannot benefit from these so we will go through the whole process by hand.  Click on the interval we just created to bring a little '+' sign attached to the interval. Click that '+' sign to open up the processes library. The window displays different banks each containing various processes. From the 'automations' bank, choose 'automation (float)'. Double-click (or click the '+' button) then close the window. We now created an automation.   We first have to set the name of the parameter we want to automate. Click on the automation header (displaying \"Automation\" as a greyed out label) to bring its inspector. From the Device explorer, select the parameter to automate (ie 'modulation/ratio') and drag it over to 'Address' field the automation inspector. The automation will now use this parameter as destination.   The automation process offers a number of embedded function (standard easing functions, waveforms, etc.). Hence, rather than adding points and curve, here we will use the noise generator. In the automation box, select the red segment then right-click. From the function contextual menu, navigate through the 'Automation (float)   Type' section then choose 'noise'. Score now filled our automation process with a random function.   One more thing we may want to do before listening to our composition. When doing automation, Score use by default the min/max values of the automated parameter. Here, we will adjust these bounds so the automation runs in a user-defined range.  From the automation inspector, check the min and max textfield and set desired values. We will arbitrary use a minimum value of 5 and maximum value of 9. But feel free to experiment and adjust to your taste!", 
            "title": "Writing processes"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#summary", 
            "text": "We now covered the major features of the Score workflow: setting up your devices network, storing   recalling snapshots, writing automations for the parameters of your device, write precise temporal structure.  Score offers a number of other features depending on the protocols used to communicate with your devices, handy shortcuts to ease the writing of complex performances or installations, vast collection of available processes that will get covered in the following on the documentation.  In the mean time, this should get you the needed basis to start with Score scenario authoring.  You may now sit comfortably, relax and enjoy your composition. Or just start experimenting !", 
            "title": "Summary"
        }, 
        {
            "location": "/in_depth/automation_process/index.html", 
            "text": "Process overview: Automation\n\n\nPresentation\n\n\nIt is a curve that represents the variation of the value of an address in time, bounded between a \nminimum\n and a \nmaximum\n, with an optional \nunit\n. It can also be used for tweening, that is ramping from a point defined during execution to a point value specified in the automation.\n\n\n\n\nFunction edition\n\n\nBasic editing\n\n\nAutomations can have multiple break-points, between each are curve segments.\n\n\nWhen adding an automation process, default function is an ascendant line going from the parameter minimal value or its value stored in the preceding state, to the maximum parameter value or its value stored in the consecutive state.\n\n\nNew break-points can be added by double clicking in the automation panel or using \ncmd + click\n (macOS) or `Ctrl + click (Windows).\n\n\n\n\nBy default, the curvature of a segment can be modified by selecting the segment to edit and using \nshift + drag\n to adjust curvature amount. Moving the mouse upward or downward will curve the segment in the corresponding direction.\n\n\n\n\n\n\nNote that adjusting the curvature of a segment is only available when using the default \"Power\" curve segment type\n\n\n\n\nPoints of the automation can be deleted by selecting them and pressing the \ndelete\n or \nbackspace\n key.\n\n\nAdvance editing\n\n\nThe automation editor provides different options for point displacement. By default, moving a point horizontally is locked to the x position of the preceding and following point.\n\n\nPoint displacement can be unlocked from the function contextual menu. To do so, right click in the automation editor and uncheck the option: \nAutomation (float) \n Lock between points\n. When unlocked, moving a point beyond its preceding or following point will delete them.\n\n\n\n\nOverwriting of the adjacent points can be prevented from by unchecking the option in the automation editor contextual menu: \nAutomation (float) \n Suppress on overlap\n.\n\n\n\n\nFunction types\n\n\nOther curve segments are available, including the common easing functions :\n\n\n\n\nTo set a function type, right click in the automation editor and select the desired type: \nAutomation (float) \n Type\n\n\nTween mode\n\n\nAutomation can be used in tween mode. To do so, from the automation Inspector, check the corresponding option. When checked, the automation will tween from the current value of the address.\n\n\n\n\n\n\nNotice that in tween mode, first curve segment will become dashed\n\n\n\n\nWhen playing, if the value of the address when the automation is reached is 50, then the first segment will interpolate from 50 to the value of the second point.\n\n\nRelated topic\n\n\n\n\nAdding processes\n\n\nAddressing value", 
            "title": "Automation Process"
        }, 
        {
            "location": "/in_depth/automation_process/index.html#process-overview-automation", 
            "text": "", 
            "title": "Process overview: Automation"
        }, 
        {
            "location": "/in_depth/automation_process/index.html#presentation", 
            "text": "It is a curve that represents the variation of the value of an address in time, bounded between a  minimum  and a  maximum , with an optional  unit . It can also be used for tweening, that is ramping from a point defined during execution to a point value specified in the automation.", 
            "title": "Presentation"
        }, 
        {
            "location": "/in_depth/automation_process/index.html#function-edition", 
            "text": "", 
            "title": "Function edition"
        }, 
        {
            "location": "/in_depth/automation_process/index.html#basic-editing", 
            "text": "Automations can have multiple break-points, between each are curve segments.  When adding an automation process, default function is an ascendant line going from the parameter minimal value or its value stored in the preceding state, to the maximum parameter value or its value stored in the consecutive state.  New break-points can be added by double clicking in the automation panel or using  cmd + click  (macOS) or `Ctrl + click (Windows).   By default, the curvature of a segment can be modified by selecting the segment to edit and using  shift + drag  to adjust curvature amount. Moving the mouse upward or downward will curve the segment in the corresponding direction.    Note that adjusting the curvature of a segment is only available when using the default \"Power\" curve segment type   Points of the automation can be deleted by selecting them and pressing the  delete  or  backspace  key.", 
            "title": "Basic editing"
        }, 
        {
            "location": "/in_depth/automation_process/index.html#advance-editing", 
            "text": "The automation editor provides different options for point displacement. By default, moving a point horizontally is locked to the x position of the preceding and following point.  Point displacement can be unlocked from the function contextual menu. To do so, right click in the automation editor and uncheck the option:  Automation (float)   Lock between points . When unlocked, moving a point beyond its preceding or following point will delete them.   Overwriting of the adjacent points can be prevented from by unchecking the option in the automation editor contextual menu:  Automation (float)   Suppress on overlap .", 
            "title": "Advance editing"
        }, 
        {
            "location": "/in_depth/automation_process/index.html#function-types", 
            "text": "Other curve segments are available, including the common easing functions :   To set a function type, right click in the automation editor and select the desired type:  Automation (float)   Type", 
            "title": "Function types"
        }, 
        {
            "location": "/in_depth/automation_process/index.html#tween-mode", 
            "text": "Automation can be used in tween mode. To do so, from the automation Inspector, check the corresponding option. When checked, the automation will tween from the current value of the address.    Notice that in tween mode, first curve segment will become dashed   When playing, if the value of the address when the automation is reached is 50, then the first segment will interpolate from 50 to the value of the second point.", 
            "title": "Tween mode"
        }, 
        {
            "location": "/in_depth/automation_process/index.html#related-topic", 
            "text": "Adding processes  Addressing value", 
            "title": "Related topic"
        }, 
        {
            "location": "/in_depth/interpolation_process/index.html", 
            "text": "Process overview: Interpolation\n\n\nPresentation\n\n\nThe interpolation is very similar to the automation.\nIt sends a set of values over time, given by a curve, and it is green instead of red.\nHowever, instead of sending values that graphically looks like the curve, it sends values\nthat are interpolated between the first and last state of the parent interval for its address.\n\n\n\n\nEdition\n\n\nFrom an edition point of view, an interpolation is identical to an automation : it is just a curve.\n\n\nExecution\n\n\nIn order to work, an interpolation requires :\n\n\n\n\nAn address\n\n\nA start state with a value for this address\n\n\nAn end state with a value for this address\n\n\n\n\nFor instance, with comment blocks to show what's in the states :\n\n\n\n\nFor now, this curve behaves exactly like an automation : at t=0, the value 0 will be sent, at mid-course, the value 25, and at the end, the value 50.\n\n\nA first difference arises if the states are in the other order :\n\n\n\n\nHere, even though the curve seems to increase, the value will actually do 50, 49, ..., 25, ..., 0.\nBasically:\n\n\n\n\nA point at the \nbottom\n of the curve has the value of the \nstart\n start\n\n\nA point at the \ntop\n of the curve has the value of the \nend\n state\n\n\n\n\nThe interpolation is also useful with arrays : each array value will be interpolated one-by-one.\nFor instance, in this case :\n\n\n\n\nThe sent values will look like [ 10, 0, 5 ],\u00a0 [ 9, 1, 5 ], ..., [ 5, 5, 5 ], ..., [ 0, 10, 5 ].\n\n\nValues of non-interpolable types (strings) will just be copied for each sent message.", 
            "title": "Interpolation Process"
        }, 
        {
            "location": "/in_depth/interpolation_process/index.html#process-overview-interpolation", 
            "text": "", 
            "title": "Process overview: Interpolation"
        }, 
        {
            "location": "/in_depth/interpolation_process/index.html#presentation", 
            "text": "The interpolation is very similar to the automation.\nIt sends a set of values over time, given by a curve, and it is green instead of red.\nHowever, instead of sending values that graphically looks like the curve, it sends values\nthat are interpolated between the first and last state of the parent interval for its address.", 
            "title": "Presentation"
        }, 
        {
            "location": "/in_depth/interpolation_process/index.html#edition", 
            "text": "From an edition point of view, an interpolation is identical to an automation : it is just a curve.", 
            "title": "Edition"
        }, 
        {
            "location": "/in_depth/interpolation_process/index.html#execution", 
            "text": "In order to work, an interpolation requires :   An address  A start state with a value for this address  An end state with a value for this address   For instance, with comment blocks to show what's in the states :   For now, this curve behaves exactly like an automation : at t=0, the value 0 will be sent, at mid-course, the value 25, and at the end, the value 50.  A first difference arises if the states are in the other order :   Here, even though the curve seems to increase, the value will actually do 50, 49, ..., 25, ..., 0.\nBasically:   A point at the  bottom  of the curve has the value of the  start  start  A point at the  top  of the curve has the value of the  end  state   The interpolation is also useful with arrays : each array value will be interpolated one-by-one.\nFor instance, in this case :   The sent values will look like [ 10, 0, 5 ],\u00a0 [ 9, 1, 5 ], ..., [ 5, 5, 5 ], ..., [ 0, 10, 5 ].  Values of non-interpolable types (strings) will just be copied for each sent message.", 
            "title": "Execution"
        }, 
        {
            "location": "/in_depth/mapping_process/index.html", 
            "text": "Process overview: Mapping\n\n\nPresentation\n\n\nThe mapping process allows to map \u00a0input parameters to output parameters in real-time.\nIt is a simple transfer function.\nIt is based on a curve, just like the automation.\nHowever, it is a time-independent process : instead of mapping the time to a value, it maps an input value to an output value.\n\n\nIts curve is purple.\n\n\n\n\nEdition\n\n\nFrom an edition point of view, a mapping is identical to an automation : it is just a curve.\nHowever, since it is not temporal, growing the process with the Grow mode has no effect : it will always be rescaled.\n\n\nInspector\n\n\nThe mapping inspector is very simple :\n\n\n\n\nThe parameters are :\n\n\n\n\nSource address : its value will be fetched at each tick. Like elsewhere in the software, accessing a single value of an array is supported, as well as unit conversions\n\n\nSource min / max : the values in which the input is assumed to be\n\n\nTarget address : the address that will be written to\n\n\nTarget min / max : the output range\n\n\n\n\nExecution\n\n\nThe mapping behaves as follows at each tick :\n\n\n\n\nThe current value of the source address is fetched\n\n\nIt is mapped to the X axis of the curve according to the source min-max\n\n\nThe corresponding point is taken on the Y axis\n\n\nThis point is scaled according to the target min-max\n\n\nThe resulting value is sent to the target address\n\n\n\n\nFor instance, the following curve with identical min-max for the source and target would just\ncopy its input to its output at each tick :\n\n\n\n\nIf the target max is set to twice the source max (for instance from (0, 1) to (0, 2)), all the input values will be multiplied by two.\n\n\nThe following curve will invert the input values.\n\n\n\n\nMore complex curves will of course have more complex effects.", 
            "title": "Mapping Process"
        }, 
        {
            "location": "/in_depth/mapping_process/index.html#process-overview-mapping", 
            "text": "", 
            "title": "Process overview: Mapping"
        }, 
        {
            "location": "/in_depth/mapping_process/index.html#presentation", 
            "text": "The mapping process allows to map \u00a0input parameters to output parameters in real-time.\nIt is a simple transfer function.\nIt is based on a curve, just like the automation.\nHowever, it is a time-independent process : instead of mapping the time to a value, it maps an input value to an output value.  Its curve is purple.", 
            "title": "Presentation"
        }, 
        {
            "location": "/in_depth/mapping_process/index.html#edition", 
            "text": "From an edition point of view, a mapping is identical to an automation : it is just a curve.\nHowever, since it is not temporal, growing the process with the Grow mode has no effect : it will always be rescaled.", 
            "title": "Edition"
        }, 
        {
            "location": "/in_depth/mapping_process/index.html#inspector", 
            "text": "The mapping inspector is very simple :   The parameters are :   Source address : its value will be fetched at each tick. Like elsewhere in the software, accessing a single value of an array is supported, as well as unit conversions  Source min / max : the values in which the input is assumed to be  Target address : the address that will be written to  Target min / max : the output range", 
            "title": "Inspector"
        }, 
        {
            "location": "/in_depth/mapping_process/index.html#execution", 
            "text": "The mapping behaves as follows at each tick :   The current value of the source address is fetched  It is mapped to the X axis of the curve according to the source min-max  The corresponding point is taken on the Y axis  This point is scaled according to the target min-max  The resulting value is sent to the target address   For instance, the following curve with identical min-max for the source and target would just\ncopy its input to its output at each tick :   If the target max is set to twice the source max (for instance from (0, 1) to (0, 2)), all the input values will be multiplied by two.  The following curve will invert the input values.   More complex curves will of course have more complex effects.", 
            "title": "Execution"
        }, 
        {
            "location": "/in_depth/loop_process/index.html", 
            "text": "Process overview: Loop\n\n\nPresentation\n\n\nThe loop is somewhat similar to the scenario.\n\n\nIt is a process that allows to loop other processes.\n\n\nHowever no new structures can be created or removed in it.\n\n\nIt is built of :\n\n\n\n\nA first sync, event, and state\n\n\nA time constraint\n\n\nA last sync, event, and state\n\n\n\n\nWhen created, it looks like this :\n\n\n\n\nEdition\n\n\nThe last event can be resized :\n\n\n\n\nProcesses can of course be added to the interval, as well as data to the states.\n\n\nExecution\n\n\nThe loop process, as its name tells, loops :\n\n\n\n\nTo make an infinite loop, one can for instance remove the maximum of its parent interval :\n\n\n\n\nTo make an interactive loop, a trigger can instead be added at the first or last trigger of the loop :", 
            "title": "Loop Process"
        }, 
        {
            "location": "/in_depth/loop_process/index.html#process-overview-loop", 
            "text": "", 
            "title": "Process overview: Loop"
        }, 
        {
            "location": "/in_depth/loop_process/index.html#presentation", 
            "text": "The loop is somewhat similar to the scenario.  It is a process that allows to loop other processes.  However no new structures can be created or removed in it.  It is built of :   A first sync, event, and state  A time constraint  A last sync, event, and state   When created, it looks like this :", 
            "title": "Presentation"
        }, 
        {
            "location": "/in_depth/loop_process/index.html#edition", 
            "text": "The last event can be resized :   Processes can of course be added to the interval, as well as data to the states.", 
            "title": "Edition"
        }, 
        {
            "location": "/in_depth/loop_process/index.html#execution", 
            "text": "The loop process, as its name tells, loops :   To make an infinite loop, one can for instance remove the maximum of its parent interval :   To make an interactive loop, a trigger can instead be added at the first or last trigger of the loop :", 
            "title": "Execution"
        }, 
        {
            "location": "/in_depth/scenario_process/index.html", 
            "text": "Process overview: Scenario\n\n\nPresentation\n\n\nThe scenario process is the heart of \nscore\n, its \nraison d'\u00eatre\n.\nIt allows to sequence the various objects presented before in a non-linear timeline.\n\n\nWhen opening \nscore\n for the first time, the blank document is a root Time interval, the blue line at the top, which\ncontains a single scenario.\n\n\n\n\nEdition\n\n\nThe various edition features of a scenario are detailed in the tutorials.\n\n\nSub-scenarios can of course be added :\n\n\n\n\nFull-view and hierarchy\n\n\nOne can go inside sub-scenarios by using the Full-view feature of the interval.\n\n\nBy double-clicking on a interval name, it switches to the main view.", 
            "title": "Scenario Process"
        }, 
        {
            "location": "/in_depth/scenario_process/index.html#process-overview-scenario", 
            "text": "", 
            "title": "Process overview: Scenario"
        }, 
        {
            "location": "/in_depth/scenario_process/index.html#presentation", 
            "text": "The scenario process is the heart of  score , its  raison d'\u00eatre .\nIt allows to sequence the various objects presented before in a non-linear timeline.  When opening  score  for the first time, the blank document is a root Time interval, the blue line at the top, which\ncontains a single scenario.", 
            "title": "Presentation"
        }, 
        {
            "location": "/in_depth/scenario_process/index.html#edition", 
            "text": "The various edition features of a scenario are detailed in the tutorials.  Sub-scenarios can of course be added :", 
            "title": "Edition"
        }, 
        {
            "location": "/in_depth/scenario_process/index.html#full-view-and-hierarchy", 
            "text": "One can go inside sub-scenarios by using the Full-view feature of the interval.  By double-clicking on a interval name, it switches to the main view.", 
            "title": "Full-view and hierarchy"
        }, 
        {
            "location": "/in_depth/value_addressing/index.html", 
            "text": "Advanced value addressing\n\n\nScore\n provides various features to ease the managment of parameters. These are specially useful when writing complex processes (e.g automations).\n\n\nAddressing items in arrays\n\n\nWhen a parameter of a declared device defines a set of values (e.g parameters defining an xyz position or an rgb color), items in this array can accessed independantly using a special syntaxe: a parameter address may be followed by an integer (starting from zero) definiting position in the array put in brackets.\n\n\nFor example, using \naDevice:/anAddress[1]\n as a destination address of an automation will send the automation value to the \nsecond\n element in the array.\n\n\n\n\nNote that without specifying an index, automation sent to array parameter (ie. \nvec2f\n, \nvec3f\n, list) will affect all items in the array\n\n\n\n\nUsing unit conversion\n\n\nParameter of a declared device may also be specified a particular unit (e.g parameters defining a position in space or a color). \nScore\n embeds some unit conversion for advanced automations. Unit to execute an automation on can be spet using a similar bracket-based syntaxe.\n\n\nFor example, using \naDevice:/anAddress[angle.radian]\n as a destination address of an automation will send the value in this unit (ie. radian). The value will be converted back to the address's original unit upon sending.\n\n\nCombining item addressing and unit\n\n\naDevice:/anAddress[color.rgb.r] : same as before, but for a specific component of an unit.", 
            "title": "Avanced value addressing"
        }, 
        {
            "location": "/in_depth/value_addressing/index.html#advanced-value-addressing", 
            "text": "Score  provides various features to ease the managment of parameters. These are specially useful when writing complex processes (e.g automations).", 
            "title": "Advanced value addressing"
        }, 
        {
            "location": "/in_depth/value_addressing/index.html#addressing-items-in-arrays", 
            "text": "When a parameter of a declared device defines a set of values (e.g parameters defining an xyz position or an rgb color), items in this array can accessed independantly using a special syntaxe: a parameter address may be followed by an integer (starting from zero) definiting position in the array put in brackets.  For example, using  aDevice:/anAddress[1]  as a destination address of an automation will send the automation value to the  second  element in the array.   Note that without specifying an index, automation sent to array parameter (ie.  vec2f ,  vec3f , list) will affect all items in the array", 
            "title": "Addressing items in arrays"
        }, 
        {
            "location": "/in_depth/value_addressing/index.html#using-unit-conversion", 
            "text": "Parameter of a declared device may also be specified a particular unit (e.g parameters defining a position in space or a color).  Score  embeds some unit conversion for advanced automations. Unit to execute an automation on can be spet using a similar bracket-based syntaxe.  For example, using  aDevice:/anAddress[angle.radian]  as a destination address of an automation will send the value in this unit (ie. radian). The value will be converted back to the address's original unit upon sending.", 
            "title": "Using unit conversion"
        }, 
        {
            "location": "/in_depth/value_addressing/index.html#combining-item-addressing-and-unit", 
            "text": "aDevice:/anAddress[color.rgb.r] : same as before, but for a specific component of an unit.", 
            "title": "Combining item addressing and unit"
        }, 
        {
            "location": "/howtos/declare_an_osc_device/index.html", 
            "text": "How to setup an OSC device ?\n\n\nTo setup an Open Sound Control compatible device to be used with Score, click the \n+\n button at the bottom left of the \nDevice explorer\n pane or use \ncmd + B\n (on MacOS) / \nctrl + B\n (on Windows) shortcut. This prompts a configuration window where we can setup various protocols informations.\n\n\n\n\nFrom the \nProtocol\n menu, select OSC. This brings the various option fields needed to setup the communication between your application and Score:\n\n\n\n\nA name for the device (used for display only)\n\n\nThe network port your application will receive OSC messages from\n\n\nThe network port Score will receive OSC messages from (assuming your application can echo back its parameters current state)\n\n\nIP address of the computer of your application is running on.\n\n\n\n\n\n\nThese setup up the communication between Score and your application.\n\n\n\n\nThe setup of your OSC device can be adjusted at any time, by right-clicking on your device name in the Device explorer pane and choose \nEdit\n from the contextual menu.\n\n\n\n\nWhen done, you may either:\n\n\n\n\nLoad a namespace file from the device setup window that describes all the parameters of your application\n\n\nUse the \nlearn\n function available when \nright-clicking your device name in the Device explorer\n\n\nManually declare the namespace in the Device explorer pane", 
            "title": "Setup an OSC device"
        }, 
        {
            "location": "/howtos/declare_an_osc_device/index.html#how-to-setup-an-osc-device", 
            "text": "To setup an Open Sound Control compatible device to be used with Score, click the  +  button at the bottom left of the  Device explorer  pane or use  cmd + B  (on MacOS) /  ctrl + B  (on Windows) shortcut. This prompts a configuration window where we can setup various protocols informations.   From the  Protocol  menu, select OSC. This brings the various option fields needed to setup the communication between your application and Score:   A name for the device (used for display only)  The network port your application will receive OSC messages from  The network port Score will receive OSC messages from (assuming your application can echo back its parameters current state)  IP address of the computer of your application is running on.    These setup up the communication between Score and your application.   The setup of your OSC device can be adjusted at any time, by right-clicking on your device name in the Device explorer pane and choose  Edit  from the contextual menu.   When done, you may either:   Load a namespace file from the device setup window that describes all the parameters of your application  Use the  learn  function available when  right-clicking your device name in the Device explorer  Manually declare the namespace in the Device explorer pane", 
            "title": "How to setup an OSC device ?"
        }, 
        {
            "location": "/howtos/manual_namespace_setup/index.html", 
            "text": "How to manually declare a namespace ?\n\n\nWhen not using Score with an application providing querying mechanism (such as OSCQuery) or echoing its parameters state, you need to manually add the parameter addresses to your device setup. Once having \nsetup an OSC device\n, click on the device name and from the contextual menu, choose \nAdd child\n to add an address at a level below. (you may as well choose \nAdd sibling\n when right-clicking on a parameter name to add a parameter at the same hierarchical level)\n\n\n\n\nThis brings a configuration window for the parameter to declare in the namespace.\n\n\nScore (along with some compatible protocols such as OSCQuery or Minuit) offers a number of attributes describing a parameter behaviour. Setting up these attributes allows to benefit from a number of Score handy features such as automatic value range setup when writing automations, repetitions filtering or unit conversion, to name a few.\n\n\n\n\nThese attributes are the following:\n\n\n\n\nParameter name\n\n\nType of value\n\n\nDefault value\n\n\nDomain (range)\n\n\nClip mode\n\n\nI/O type\n\n\nRepetitions filter\n\n\nOptional tags\n\n\nUnit\n\n\nDescription\n\n\n\n\nPlease see \nlibossia documentation page\n for detailed explanation on these attributes.\n\n\nJust fill these various optional attributes for the parameter to declare then click the \nOk\n button. Freshly created parameter now appears in the Device explorer.\n\n\n\n\nNote that at the time of this writing, it is not possible to add in one go a parameter under several nodes (ie. \n/foo/bar/my_parameter\n). For the time being, you need to add the various nodes one at each time and set \ncontainer\n as type. Then right-click on the created node and select \nAdd child\n as many times as needed.\n\n\n\n\nSaving namespace as a file\n\n\nWhen done adding the various parameters of your device, you can save the resulting namespace as a file for later use. Hence when working with this device in another project, you will be able to import the namespace when setting up the device and avoid the tedious manual namespace declaration above.\n\n\nTo do so, right-click on your device name, then from the contextual menu, choose \nExport device\n.", 
            "title": "Manually declare a namespace"
        }, 
        {
            "location": "/howtos/manual_namespace_setup/index.html#how-to-manually-declare-a-namespace", 
            "text": "When not using Score with an application providing querying mechanism (such as OSCQuery) or echoing its parameters state, you need to manually add the parameter addresses to your device setup. Once having  setup an OSC device , click on the device name and from the contextual menu, choose  Add child  to add an address at a level below. (you may as well choose  Add sibling  when right-clicking on a parameter name to add a parameter at the same hierarchical level)   This brings a configuration window for the parameter to declare in the namespace.  Score (along with some compatible protocols such as OSCQuery or Minuit) offers a number of attributes describing a parameter behaviour. Setting up these attributes allows to benefit from a number of Score handy features such as automatic value range setup when writing automations, repetitions filtering or unit conversion, to name a few.   These attributes are the following:   Parameter name  Type of value  Default value  Domain (range)  Clip mode  I/O type  Repetitions filter  Optional tags  Unit  Description   Please see  libossia documentation page  for detailed explanation on these attributes.  Just fill these various optional attributes for the parameter to declare then click the  Ok  button. Freshly created parameter now appears in the Device explorer.   Note that at the time of this writing, it is not possible to add in one go a parameter under several nodes (ie.  /foo/bar/my_parameter ). For the time being, you need to add the various nodes one at each time and set  container  as type. Then right-click on the created node and select  Add child  as many times as needed.", 
            "title": "How to manually declare a namespace ?"
        }, 
        {
            "location": "/howtos/manual_namespace_setup/index.html#saving-namespace-as-a-file", 
            "text": "When done adding the various parameters of your device, you can save the resulting namespace as a file for later use. Hence when working with this device in another project, you will be able to import the namespace when setting up the device and avoid the tedious manual namespace declaration above.  To do so, right-click on your device name, then from the contextual menu, choose  Export device .", 
            "title": "Saving namespace as a file"
        }, 
        {
            "location": "/howtos/namespace_learning/index.html", 
            "text": "How to use the learn function to build your application namespace ?\n\n\nOnce having \nsetup an OSC device\n, you may want to use the Device explorer's learn feature to ease the declaration of all the parameter addresses of the application you want to control from Score. To do so, in the Device explorer, right-click on your device name then from the contextual menu, choose \nlearn\n.\n\n\n\n\nThis brings a popup window displaying learnt parameters address. Assuming echoing of the parameters value is properly setup in your distant application, you may now start changing their value (ie. From the GUI) so they get sent back to Score. These should appear in Score's \nOSC learning\n window. \n\n\n\n\nWhen done in your distant application, press the \nreturn\n key or click the \nOk\n button.\n\n\nThe Device explorer should now display all parameters from your device as a tree-like view.\n\n\nEditing parameters attributes\n\n\nUsing the learn function only set the namespace structure of your distant application. You may want to specify these parameters in order to benefit from Score parameter attributes-dependant features (ie. Automatic value range setup when writing automations, repetitions filtering, unit conversion).\n\n\nTo do so, in the Device explorer right-click on a parameter name of your device, then choose \nEdit\n. This bring a configuration window allowing to edit various attributes describing a parameter behaviour.\n\n\n\n\nThe attributes are the following:\n\n\n\n\nParameter name\n\n\nType of value\n\n\nDefault value\n\n\nDomain (range)\n\n\nClip mode\n\n\nI/O type\n\n\nRepetitions filter\n\n\nOptional tags\n\n\nUnit\n\n\nDescription\n\n\n\n\nPlease see \nlibossia documentation page\n for detailed explanation on these attributes.", 
            "title": "Use the learn function"
        }, 
        {
            "location": "/howtos/namespace_learning/index.html#how-to-use-the-learn-function-to-build-your-application-namespace", 
            "text": "Once having  setup an OSC device , you may want to use the Device explorer's learn feature to ease the declaration of all the parameter addresses of the application you want to control from Score. To do so, in the Device explorer, right-click on your device name then from the contextual menu, choose  learn .   This brings a popup window displaying learnt parameters address. Assuming echoing of the parameters value is properly setup in your distant application, you may now start changing their value (ie. From the GUI) so they get sent back to Score. These should appear in Score's  OSC learning  window.    When done in your distant application, press the  return  key or click the  Ok  button.  The Device explorer should now display all parameters from your device as a tree-like view.", 
            "title": "How to use the learn function to build your application namespace ?"
        }, 
        {
            "location": "/howtos/namespace_learning/index.html#editing-parameters-attributes", 
            "text": "Using the learn function only set the namespace structure of your distant application. You may want to specify these parameters in order to benefit from Score parameter attributes-dependant features (ie. Automatic value range setup when writing automations, repetitions filtering, unit conversion).  To do so, in the Device explorer right-click on a parameter name of your device, then choose  Edit . This bring a configuration window allowing to edit various attributes describing a parameter behaviour.   The attributes are the following:   Parameter name  Type of value  Default value  Domain (range)  Clip mode  I/O type  Repetitions filter  Optional tags  Unit  Description   Please see  libossia documentation page  for detailed explanation on these attributes.", 
            "title": "Editing parameters attributes"
        }, 
        {
            "location": "/howtos/update_state/index.html", 
            "text": "How to update parameters value\n\n\nUsing the refresh function\n\n\nWhen using Score with a device providing bidirectional protocol such as OSCquery, Score listens to parameters changes in the controlled device. Stored states can then be updated by selecting the state to update on the timeline and click the 'Refresh state' button in the toolbar or use \ncmd + u\n on macOS or \nctrl + u\n on Windows.\n\n\nIf your device can only receive messages from Score, in the Device explorer, double-click on a parameter's value textfield and type the desired value. Now lick the 'Refresh state' button in the toolbar or use \ncmd + u\n on macOS or \nctrl + u\n on Windows.\n\n\n\n\nUsing the inspector\n\n\nAlternatively, stored states can be edited from a state inspector.\n\n\nOn the timeline, select the state to edit to display its inspector. From the tree view of the stored addresses and value, double-click on the value textfield and type the desired value.\n\n\nDrag\u2019n\u2019dropping from the Device Explorer\n\n\nOn can also update the existing parameters from a state by drag\u2019n\u2019dropping them from the Device Explorer.\n\n\nThis allows to:\n- only update a portion of the parameters\n- add new parameters while updating those already present.\n\n\nWhen doing so, the parameters already present will be updated, when applicable. Those that were not present beforehands will be added with the current value from the Device Explorer", 
            "title": "Update stored state"
        }, 
        {
            "location": "/howtos/update_state/index.html#how-to-update-parameters-value", 
            "text": "", 
            "title": "How to update parameters value"
        }, 
        {
            "location": "/howtos/update_state/index.html#using-the-refresh-function", 
            "text": "When using Score with a device providing bidirectional protocol such as OSCquery, Score listens to parameters changes in the controlled device. Stored states can then be updated by selecting the state to update on the timeline and click the 'Refresh state' button in the toolbar or use  cmd + u  on macOS or  ctrl + u  on Windows.  If your device can only receive messages from Score, in the Device explorer, double-click on a parameter's value textfield and type the desired value. Now lick the 'Refresh state' button in the toolbar or use  cmd + u  on macOS or  ctrl + u  on Windows.", 
            "title": "Using the refresh function"
        }, 
        {
            "location": "/howtos/update_state/index.html#using-the-inspector", 
            "text": "Alternatively, stored states can be edited from a state inspector.  On the timeline, select the state to edit to display its inspector. From the tree view of the stored addresses and value, double-click on the value textfield and type the desired value.", 
            "title": "Using the inspector"
        }, 
        {
            "location": "/howtos/update_state/index.html#dragndropping-from-the-device-explorer", 
            "text": "On can also update the existing parameters from a state by drag\u2019n\u2019dropping them from the Device Explorer.  This allows to:\n- only update a portion of the parameters\n- add new parameters while updating those already present.  When doing so, the parameters already present will be updated, when applicable. Those that were not present beforehands will be added with the current value from the Device Explorer", 
            "title": "Drag\u2019n\u2019dropping from the Device Explorer"
        }
    ]
}