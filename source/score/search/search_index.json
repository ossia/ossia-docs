{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Score documentation\n\n\n\n\nVersion 2.0.0.a4", 
            "title": "Home"
        }, 
        {
            "location": "/index.html#score-documentation", 
            "text": "Version 2.0.0.a4", 
            "title": "Score documentation"
        }, 
        {
            "location": "/first_steps/score-presentation/index.html", 
            "text": "Introduction\n\n\nScore is an interactive sequencer for intermedia creation. It allows to create flexible and interactive scenarios and is especially designed for live performance, art installation, museography or any context requiring a precise and interactive execution of timed events.\n\n\nScore brings a flexible solution to the managment and execution of events and their evolution in time. Modern DAWs now offer a number of tools to write precise automations along a timeline. However, as powerful as these are in the context of fixed-time media, such solutions are of little help when introducing interactivity in the execution of produced scenarios. On the other hand, a number of softwares allows to trigger events in an interactive way, through a cue-based paradigm. However, these may not offer automation facilities as advanced as those found in modern DAW and also often rely on a sequential and linear triggering of events.\n\n\nScore brings these two approaches in a unified timeline. Scenario authoring and execution in Score thus makes possible to write fixed-timed automations as well as sequences of automations triggered interactively. Most importantly, these two paradigms can be combined and used in parallel or hierarchically and provide the high level of control as well as openess required by today\u2019s creation.\n\n\n\n\nA sequencer for distributed media systems\n\n\nUnlike other digital multimedia workstations, Score does not aim at being an all at once software. Instead, it is designed to fully integrate with dedicated softwares and hardware used in your project. \n\n\nWhile recent versions of Score allows to process media (such as audio), it takes root as a remote controller allowing to store \n recall snapshots and automations sent to some distant applications through various protocols (\nOSCQuery\n, \nOpen Sound Control\n, \nMidi\n or \nMinuit\n). Hence it can easily be used in large setups involving video, audio or light software or hardware to provide a unified and global solution to control parameters changes in a synchronous or asynchronous way across your applications.\n\n\n\n\nScore's features in a nutshell\n\n\nThis documentation will walk you through Score's basis concepts and advanced features to ease the mastering of its features.\n\n\n\n\nStore \n recall snapshots\n\n\nUse processes to write your application's parameters behaviour in time (BPF, interpolations, gradients)\n\n\nlinearly organize snapchots \n processes on the timeline\n\n\ntrigger events interactively\n\n\nusing local loops\n\n\nbranching scenarios\n\n\n\n\nAnd more...", 
            "title": "Introduction"
        }, 
        {
            "location": "/first_steps/score-presentation/index.html#introduction", 
            "text": "Score is an interactive sequencer for intermedia creation. It allows to create flexible and interactive scenarios and is especially designed for live performance, art installation, museography or any context requiring a precise and interactive execution of timed events.  Score brings a flexible solution to the managment and execution of events and their evolution in time. Modern DAWs now offer a number of tools to write precise automations along a timeline. However, as powerful as these are in the context of fixed-time media, such solutions are of little help when introducing interactivity in the execution of produced scenarios. On the other hand, a number of softwares allows to trigger events in an interactive way, through a cue-based paradigm. However, these may not offer automation facilities as advanced as those found in modern DAW and also often rely on a sequential and linear triggering of events.  Score brings these two approaches in a unified timeline. Scenario authoring and execution in Score thus makes possible to write fixed-timed automations as well as sequences of automations triggered interactively. Most importantly, these two paradigms can be combined and used in parallel or hierarchically and provide the high level of control as well as openess required by today\u2019s creation.", 
            "title": "Introduction"
        }, 
        {
            "location": "/first_steps/score-presentation/index.html#a-sequencer-for-distributed-media-systems", 
            "text": "Unlike other digital multimedia workstations, Score does not aim at being an all at once software. Instead, it is designed to fully integrate with dedicated softwares and hardware used in your project.   While recent versions of Score allows to process media (such as audio), it takes root as a remote controller allowing to store   recall snapshots and automations sent to some distant applications through various protocols ( OSCQuery ,  Open Sound Control ,  Midi  or  Minuit ). Hence it can easily be used in large setups involving video, audio or light software or hardware to provide a unified and global solution to control parameters changes in a synchronous or asynchronous way across your applications.", 
            "title": "A sequencer for distributed media systems"
        }, 
        {
            "location": "/first_steps/score-presentation/index.html#scores-features-in-a-nutshell", 
            "text": "This documentation will walk you through Score's basis concepts and advanced features to ease the mastering of its features.   Store   recall snapshots  Use processes to write your application's parameters behaviour in time (BPF, interpolations, gradients)  linearly organize snapchots   processes on the timeline  trigger events interactively  using local loops  branching scenarios   And more...", 
            "title": "Score's features in a nutshell"
        }, 
        {
            "location": "/first_steps/time_approach/index.html", 
            "text": "Time approach in Score\n\n\nA number of features offered in Score (ie. Snapshots, automations or interpolations processes) will most likely sound familiar to a number of users. However, as powerful and flexible the combination of fixed-time automations or interactive triggering of events is, it may be helpful to get a clear understanding of the time model that drove Score conception and induced workflow.\n\n\nA useful metaphor to understand how time is managed in Score can be to envision \ntime as a stream flowing through the scenario written on the timeline\n. Following this metaphor, Score thus provides a number of tools to define various paths on the timeline through which time will pass, to attach them events (snapshots or timed processes) that will get executed as time crosses them by, or to insert gates that will get opened or closed depending on various parameters (interactive triggering, branchings), etc.\n\n\nLet the time flow\n\n\nWhen opening Score, user gets provided a blank scenario and its default time source. When clicking the play button (or pressing \nspacebar\n key), time will start spreading along the top timeline. You can see the green progress bar advancing along the top ruler displaying time in minutes:seconds.milliseconds. Plain and simple.\n\n\n\n\nRather than providing predefined tracks for example, Score offers to organize your distant application's parameters behavior on the timeline in flexible ways. Depending on your needs or workflow, you may write different paths by inserting  some events on the timeline, and connecting them using interval links (ie. Having paths dedicated to particular devices control or dedicating paths to different rooms of an installation).\n\n\nWhen playing your scenario, you will see that \ntime flows through the various paths\n as their progress bar moves forward.\n\n\n\n\n\n\nNote how important it is that various event paths are connected to the beginning of your scenario so they get executed following the timeline. You may think of these interval links between events as \nfeeder pipes\n. They ensure that time will spread from the beginning of your scenario to the first attached event, then next one and so one. On the contrary, any event not connected to the beginning of your scenario or to another event will not get provided a time source: they will not get executed as time passes by.\n\n\n\n\nOpen the floodgate !\n\n\nOne of Score's strength is the introduction of the time flexibility usually found in cue-based softwares with a timeline approach. Score hence provides different features to break or put on hold time flow through a path in your scenario or to write several versions of a path to be chosen during the execution of your scenario. \n\n\nFirst example here is what happens when adding a trigger to an event in your scenario. As time reaches this event, execution is put on hold until event is triggered, be it from a mouse click or when a particular value is sent from a remote software or sensor. Following our time flow metaphor, when done so, the \nfloodgate will get opened\n and time will continue to flow down the path. Adjacent paths not set with a trigger will independently follow the general time flow.\n\n\n\n\nThe second mentioned example can be set when using conditions on events (ie. If a variable such as the distance between a user and a sensor is either smaller or greater than a particular threshold). When time reaches these conditional events, Score will check which conditions are true and choose which path(s) to execute. \n\n\n\n\nOf course as detailed later in this documentation, both interactive triggering and conditions can be used along with other features so you can get a precise control of time flow in your scenario.\n\n\nCascading time flow\n\n\nUsing interval links between events in your scenario ensures that time will flow along the paths and trigger events or automations as they are reached. Yet another feature allows you to precisely control how time flows: hierarchical time flow. \n\n\nEach interval in a Score scenario provides a speed control allowing to adjust during the execution of your scenario how time will travel along the paths. This makes a very useful feature, in particular for live performance when you may want to slow down a particular process (ie. Light automation) a bit as the performer on stage takes more time to reach his new position, while not affecting automations controlling another process (e.g. sound spatialization). \n\n\nBut the important point to note is that changing the speed of a given interval will also affect sub paths it is feeding time to, in a \ncascading way\n. You may think of this speed variable as an \nadjustable tap at each feeder pipe input\n. For example, when using sub-scenarios, changing the speed of the parent interval link will propagate to the whole scenario. On the other hand, changing the speed of an interval inside the sub scenario will only affect this interval and its attached events while the parent interval time will progress as written in the scenario.\n\n\n\n\nOut of time events\n\n\nAs explained above, events must get connected to a time source so they get executed as time progresses. When placed in Score\u2019s timeline without a preceding interval connection, events are what we call \ndetached from the timeline\n and their execution does not follow its progression. \n\n\nThis can be extremely useful when you want to freely send parameters value or automation at any time in the execution of you scenario. \n\n\n\n\nNote that these \ndetached events\n then provide a time source and following events or automations will get executed as time progresses from this initial event.", 
            "title": "Time approach in Score"
        }, 
        {
            "location": "/first_steps/time_approach/index.html#time-approach-in-score", 
            "text": "A number of features offered in Score (ie. Snapshots, automations or interpolations processes) will most likely sound familiar to a number of users. However, as powerful and flexible the combination of fixed-time automations or interactive triggering of events is, it may be helpful to get a clear understanding of the time model that drove Score conception and induced workflow.  A useful metaphor to understand how time is managed in Score can be to envision  time as a stream flowing through the scenario written on the timeline . Following this metaphor, Score thus provides a number of tools to define various paths on the timeline through which time will pass, to attach them events (snapshots or timed processes) that will get executed as time crosses them by, or to insert gates that will get opened or closed depending on various parameters (interactive triggering, branchings), etc.", 
            "title": "Time approach in Score"
        }, 
        {
            "location": "/first_steps/time_approach/index.html#let-the-time-flow", 
            "text": "When opening Score, user gets provided a blank scenario and its default time source. When clicking the play button (or pressing  spacebar  key), time will start spreading along the top timeline. You can see the green progress bar advancing along the top ruler displaying time in minutes:seconds.milliseconds. Plain and simple.   Rather than providing predefined tracks for example, Score offers to organize your distant application's parameters behavior on the timeline in flexible ways. Depending on your needs or workflow, you may write different paths by inserting  some events on the timeline, and connecting them using interval links (ie. Having paths dedicated to particular devices control or dedicating paths to different rooms of an installation).  When playing your scenario, you will see that  time flows through the various paths  as their progress bar moves forward.    Note how important it is that various event paths are connected to the beginning of your scenario so they get executed following the timeline. You may think of these interval links between events as  feeder pipes . They ensure that time will spread from the beginning of your scenario to the first attached event, then next one and so one. On the contrary, any event not connected to the beginning of your scenario or to another event will not get provided a time source: they will not get executed as time passes by.", 
            "title": "Let the time flow"
        }, 
        {
            "location": "/first_steps/time_approach/index.html#open-the-floodgate", 
            "text": "One of Score's strength is the introduction of the time flexibility usually found in cue-based softwares with a timeline approach. Score hence provides different features to break or put on hold time flow through a path in your scenario or to write several versions of a path to be chosen during the execution of your scenario.   First example here is what happens when adding a trigger to an event in your scenario. As time reaches this event, execution is put on hold until event is triggered, be it from a mouse click or when a particular value is sent from a remote software or sensor. Following our time flow metaphor, when done so, the  floodgate will get opened  and time will continue to flow down the path. Adjacent paths not set with a trigger will independently follow the general time flow.   The second mentioned example can be set when using conditions on events (ie. If a variable such as the distance between a user and a sensor is either smaller or greater than a particular threshold). When time reaches these conditional events, Score will check which conditions are true and choose which path(s) to execute.    Of course as detailed later in this documentation, both interactive triggering and conditions can be used along with other features so you can get a precise control of time flow in your scenario.", 
            "title": "Open the floodgate !"
        }, 
        {
            "location": "/first_steps/time_approach/index.html#cascading-time-flow", 
            "text": "Using interval links between events in your scenario ensures that time will flow along the paths and trigger events or automations as they are reached. Yet another feature allows you to precisely control how time flows: hierarchical time flow.   Each interval in a Score scenario provides a speed control allowing to adjust during the execution of your scenario how time will travel along the paths. This makes a very useful feature, in particular for live performance when you may want to slow down a particular process (ie. Light automation) a bit as the performer on stage takes more time to reach his new position, while not affecting automations controlling another process (e.g. sound spatialization).   But the important point to note is that changing the speed of a given interval will also affect sub paths it is feeding time to, in a  cascading way . You may think of this speed variable as an  adjustable tap at each feeder pipe input . For example, when using sub-scenarios, changing the speed of the parent interval link will propagate to the whole scenario. On the other hand, changing the speed of an interval inside the sub scenario will only affect this interval and its attached events while the parent interval time will progress as written in the scenario.", 
            "title": "Cascading time flow"
        }, 
        {
            "location": "/first_steps/time_approach/index.html#out-of-time-events", 
            "text": "As explained above, events must get connected to a time source so they get executed as time progresses. When placed in Score\u2019s timeline without a preceding interval connection, events are what we call  detached from the timeline  and their execution does not follow its progression.   This can be extremely useful when you want to freely send parameters value or automation at any time in the execution of you scenario.    Note that these  detached events  then provide a time source and following events or automations will get executed as time progresses from this initial event.", 
            "title": "Out of time events"
        }, 
        {
            "location": "/first_steps/meet_score_interface/index.html", 
            "text": "Meet the Score interface\n\n\nHere we will go through the various parts of Score's interface. Rather than going into each detail or advanced feature, we will first do a short run through of Score environment so you can feel at ease when going into deeper in the following tutorials.\n\n\nAs an example, we use here the demo scenario provided in the \nOverview\n folder. Feel free to open this scenario in Score as we explore core parts of the GUI as well as read the numerous comments added to it.\n\n\n\n\nOnce opened, Score provides a unique window embedding all main features and toolboxes. From it, you will be able to setup how your media applications and Score will communicate, observe their parameters value navigate through their namespace in a structured way, store some parameters value in snapshots, draw some automations, structure you scenario in flexible ways, etc. All can be done from one of the 3 UI areas:\n\n\n\n\nthe Device explorer\n\n\nScore's timeline\n\n\nobjects inspector\n\n\n\n\n\n\nNote that all main parts of Score GUI are dockable. Hence you may move them appart from main window using the button at the top right or by click+drag on their top bar. You can add them back by closing the detached window and toggling it back on in the \nView \n Windows\n menu or use the \nView \n Restore layout\n menu entry.\n\n\n\n\n\n\nDevice explorer\n\n\n\n\nFirst pane on the left of Score window is the \nDevice explorer\n pane. As its name implies, this is where you can observe the state of the devices you want to control from your Score scenario. These devices may be media applications of pieces of hardware used in your project.\n\n\nDevices are presented in the \nDevice explorer\n as a tree-like list of all parameters declared in your application (the application namespace). Using our overview.scorejson demo file, you can see two devices here are declared: a dummy OSCdevice (that can be used with one of the provided Max/Pd patches, Processing sketch or Unity project) and Score itself (so it can be controlled from the scenario). Clicking one of the triangle widgets sitting next to the devices name unfolds the list of parameters declared in the controlled applications. Subsequently, each node can be fold/unfold to display or hide its child parameters. Clicking on an address node in the Device explorer also brings a handy inspector displaying the various attributes of this node (ie. Full address, value range, optional associated tags).\n\n\nAll parameters in your devices namespace display their current value in the Device explorer right column (assuming your device provides some mechanisms to echo back parameters state). You may even send some new value for a parameter by double-clicking and typing a new value in its value textfield. The Device explorer also provides an easy way to select some parameters from the namespace by clicking on a parameter name (or a range of addresses using shift + click or any addresses using cmd + click / ctrl + click) and drag them on the Timeline. Spoiler alert: you just created a snapshot in your scenario !\n\n\nScore Timeline\n\n\nAt the centre of the window is Score's Timeline. This is where you will actually write the scenario handling the commands sent to your devices as well as do some audio synthesis or processing and their organisation in time.\n\n\n\n\nWithout going into details in this chapter (following chapters will do so), as seen in the overview.scorejson file example, commands or processes sent to your devices are organized in time using a set of elementary objects:\n\n\n\n\nevents: little blue dots with optional list of parameters values attached to it (white circle that is framing it)\n\n\nintervals: the horizontal blue lines connecting events that will stream time along the timeline\n\n\nprocesses: containers attached to an interval allowing some processes (ie. automation, mapping, custom js scripts) to operate over a dedicated time length\n\n\n\n\nAgain, following chapters in the documentation will go through each of these and their various toolboxes available. \n\n\nScore timeline also offers a synthetic view of the whole scenario at the top of the pane. From it you can zoom in/out in your scenario using \nclick + drag up/down\n or navigate in your scenario using \nclick + drag left/right\n.\n\n\n\n\nObject inspector\n\n\nLast core element of Score window is the objects inspector. This area actually provides two inspectors\n\n\n\n\nThe object inspector allowing to explore \n select elements in your scenario structure (ie. events, intervals, trigger)\n\n\nThe inspector allowing to display and edit parameters of the currently selected object (ie. state or process)\n\n\n\n\n\n\nThe object inspector at the top allows to select an object and see its hierarchical context. In the screen capture below, you will first see we can select each of the four events by selecting the sync bar connecting them, or display the processes attached to their parent interval.\n\n\nYou may also navigate through the structure of your scenario backward/forward or hierarchically using the four arrows above the list of objects as well as navigate through the history of recently selected objects.\n\n\n\n\nThe inspector below, allows to edit the various options of an object (ie. An event position on the timeline or an interval duration) and edit their attached content (ie. Addresses and values stored in a snapshot, automation's range or destination).\n\n\n\n\nOf course, actual option fields of the Inspector are dynamic and depend on which object is currently selected. These options will get detailed in the following chapters of the documentation.\n\n\nIn the mean time, this should get us basis information to get us started writing our first scenario.", 
            "title": "Meet the Score interface"
        }, 
        {
            "location": "/first_steps/meet_score_interface/index.html#meet-the-score-interface", 
            "text": "Here we will go through the various parts of Score's interface. Rather than going into each detail or advanced feature, we will first do a short run through of Score environment so you can feel at ease when going into deeper in the following tutorials.  As an example, we use here the demo scenario provided in the  Overview  folder. Feel free to open this scenario in Score as we explore core parts of the GUI as well as read the numerous comments added to it.   Once opened, Score provides a unique window embedding all main features and toolboxes. From it, you will be able to setup how your media applications and Score will communicate, observe their parameters value navigate through their namespace in a structured way, store some parameters value in snapshots, draw some automations, structure you scenario in flexible ways, etc. All can be done from one of the 3 UI areas:   the Device explorer  Score's timeline  objects inspector    Note that all main parts of Score GUI are dockable. Hence you may move them appart from main window using the button at the top right or by click+drag on their top bar. You can add them back by closing the detached window and toggling it back on in the  View   Windows  menu or use the  View   Restore layout  menu entry.", 
            "title": "Meet the Score interface"
        }, 
        {
            "location": "/first_steps/meet_score_interface/index.html#device-explorer", 
            "text": "First pane on the left of Score window is the  Device explorer  pane. As its name implies, this is where you can observe the state of the devices you want to control from your Score scenario. These devices may be media applications of pieces of hardware used in your project.  Devices are presented in the  Device explorer  as a tree-like list of all parameters declared in your application (the application namespace). Using our overview.scorejson demo file, you can see two devices here are declared: a dummy OSCdevice (that can be used with one of the provided Max/Pd patches, Processing sketch or Unity project) and Score itself (so it can be controlled from the scenario). Clicking one of the triangle widgets sitting next to the devices name unfolds the list of parameters declared in the controlled applications. Subsequently, each node can be fold/unfold to display or hide its child parameters. Clicking on an address node in the Device explorer also brings a handy inspector displaying the various attributes of this node (ie. Full address, value range, optional associated tags).  All parameters in your devices namespace display their current value in the Device explorer right column (assuming your device provides some mechanisms to echo back parameters state). You may even send some new value for a parameter by double-clicking and typing a new value in its value textfield. The Device explorer also provides an easy way to select some parameters from the namespace by clicking on a parameter name (or a range of addresses using shift + click or any addresses using cmd + click / ctrl + click) and drag them on the Timeline. Spoiler alert: you just created a snapshot in your scenario !", 
            "title": "Device explorer"
        }, 
        {
            "location": "/first_steps/meet_score_interface/index.html#score-timeline", 
            "text": "At the centre of the window is Score's Timeline. This is where you will actually write the scenario handling the commands sent to your devices as well as do some audio synthesis or processing and their organisation in time.   Without going into details in this chapter (following chapters will do so), as seen in the overview.scorejson file example, commands or processes sent to your devices are organized in time using a set of elementary objects:   events: little blue dots with optional list of parameters values attached to it (white circle that is framing it)  intervals: the horizontal blue lines connecting events that will stream time along the timeline  processes: containers attached to an interval allowing some processes (ie. automation, mapping, custom js scripts) to operate over a dedicated time length   Again, following chapters in the documentation will go through each of these and their various toolboxes available.   Score timeline also offers a synthetic view of the whole scenario at the top of the pane. From it you can zoom in/out in your scenario using  click + drag up/down  or navigate in your scenario using  click + drag left/right .", 
            "title": "Score Timeline"
        }, 
        {
            "location": "/first_steps/meet_score_interface/index.html#object-inspector", 
            "text": "Last core element of Score window is the objects inspector. This area actually provides two inspectors   The object inspector allowing to explore   select elements in your scenario structure (ie. events, intervals, trigger)  The inspector allowing to display and edit parameters of the currently selected object (ie. state or process)    The object inspector at the top allows to select an object and see its hierarchical context. In the screen capture below, you will first see we can select each of the four events by selecting the sync bar connecting them, or display the processes attached to their parent interval.  You may also navigate through the structure of your scenario backward/forward or hierarchically using the four arrows above the list of objects as well as navigate through the history of recently selected objects.   The inspector below, allows to edit the various options of an object (ie. An event position on the timeline or an interval duration) and edit their attached content (ie. Addresses and values stored in a snapshot, automation's range or destination).   Of course, actual option fields of the Inspector are dynamic and depend on which object is currently selected. These options will get detailed in the following chapters of the documentation.  In the mean time, this should get us basis information to get us started writing our first scenario.", 
            "title": "Object inspector"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html", 
            "text": "Writing your first Score scenario\n\n\nIn this short tutorial, we will write a simple scenario in Score. This should provide the basis to get familiar with Score interface and general workflow.\n\n\nHere we will use a simple frequency modulation-based synthesizer provided with Score documentation. Assuming you already have Pd or Max installed on you computer, you may use the Pd or Max version of this patch.\n\n\n\n\nIf frequency modulation synthesis does not sounds like fun to you, you may follow this tutorial using your favorite Open Sound Control (OSC) application. In that case, just follow the various steps and adjust the various options (OSC configuration, namespace configuration, etc.) to your application.\n\n\n\n\nSince we will use Score to control a distant application, we first need to setup our OSC device in Score so they can communicate properly.\n\n\nAdding your device\n\n\nOnce launched, Score opens with an empty window. To setup our OSC device, click the \n+\n button at the bottom left of the \nDevice explorer\n pane or use \ncmd + B\n (on MacOS) / \nctrl + B\n (on Windows) shortcut. This prompts a configuration window where we can setup various protocols informations.\n\n\n\n\nThe configuration window provides a list of all protocols supported in Score. Here we will select OSC from the menu. This bring the various option fields needed to setup the communication between our application and Score:\n\n\n\n\nA name for the device (used for display only)\n\n\nThe network port your application will receive OSC messages from\n\n\nThe network port Score will receive OSC messages from (assuming your application can echo back its parameters current state)\n\n\nIP address of the computer of your application is running on.\n\n\n\n\nOur simple patch example is built to use Score's OSC default ports and address so you can leave the above fields untouched. Then click the \nload\n button to load the \nfm-osc-example.device\n namespace file of our device. Press the \nreturn\n key or click the \nOK\n button. The Device explorer should now display our device named \nOSCdevice\n along with all its parameters and various attributes settings in a tree-like view.\n\n\n\n\nShould you need to modify the OSC setup of your device, right-click on your device name in the Device explorer pane and choose \nEdit\n.\n\n\n\n\nThe namespace file we just loaded is a json file describing all parameters addresses of a device we want to send values to. If using another OSC application for this tutorial, you may either use the learn feature available when right-clicking your device name in the Device explorer, or manually declare the namespace of your application. In the later case, please see the \nHow to manually declare a namespace\n documentation page.\n\n\n\n\nSetting an initial state\n\n\nWe will start by setting an \ninit\n state for our scenario. In this case, the default state of our device will be perfect as an init state so we will just store its parameters current value in the scenario initial event.\n\n\nThe easiest way to do this is to select the parameter to store from the Device explorer pane then drag them on the scenario initial event. Selection can be done using regular mouse \n key combos. Hence we can select the 'pan' parameter then \nshift + click\n on the 'frequency' parameter to select both these addresses and all between them in the tree view. For the sake of this tutorial, we will also make sure that DSP processing is turned off by default in Pd. With the current selected addresses, cmd + click (on MacOS) or ctrl + click (on Windows) on the 'stop' parameter then drag this full selection on the initial event as shown below. \n\n\n\n\nNote that selecting a node containing parameters in the namespace will select all parameters below it (ie. clicking 'modulation' selects both 'modulation/index' \n 'modulation/ratio')\n\n\n\n\n\n\nWhen done, you can see that the scenario initial event (the blue dot on the scenario timeline) is now displayed with a surrounding white circle. If you click on the state we just created, you can see in the inspector all the stored values and their associated value.\n\n\n\n\nHaving set this init state, now when reinitializing the scenario (using \ncmd + return\n on macOS or \nctrl + return\n on Windows), Score will automatically recall our device's state so it is ready to go !\n\n\n\n\nStoring states of your device\n\n\nWe will now store more states in our scenario and organize them on the timeline.\n\n\nWe will start with a simple state used to turn Pd's DSP processing on. As we previously did, let's grab the 'start' parameter and drop it on Score timeline. As you are hovering the timeline with the 'start' parameter, notice that a grey dashed line connected to the first event on the scenario is drawn. \nRemember that events and processes needed to connected to a time source\n so they get properly executed as time progress in the scenario. By default, Score then offers to automatically connect events sequentially.\n\n\n\n\nAgain, if you select the created state, you can see in its inspector that the 'start' parameter has been saved.\n\n\nYou can select this event and move it around on the timeline. Moving it horizontally lets you adjust its position on the timeline (hence when the stored parameters will get sent when playing the scenario). Vertical position has no but graphical purpose for the execution of our scenario. We can now store more states.\n\n\nThe device used in this tutorial only provides unidirectional communication (our device can only receive message from Score) so we will use the device explorer as a simple remote interface. To do so, just double-click on the value fields you want to change and type the desired value. We will for example raise the gain up to 0 dB, set the 'modulation/index' to 100 and set the 'ramptime' to 20 ms.You may now store this new state just as we did above.\n\n\n\n\nWhen using bidirectional protocol between Score and your device (ie. OSCquery), Score will listen to the parameters changes in the device. You may then make changes right from your device or using your favorites controllers (hence avoid fastidiously typing values by hand)\n\n\n\n\nSelect the addresses you want to store then drag them on the timeline. You will see that Score offers to connect this new event to the event it is most aligned with. Make sure to connect this new event to the one we previously created.\n\n\nNow follow your inspiration and store on the timeline as many of your device's states or \nfine tune them\n as you wish. \n\n\nPress the \nspacebar\n to start playing our scenario and recalling these snapshots as time moves along the timeline. You may pause the execution of our scenario pressing the \nspacebar\n again or stop it using \nreturn\n key (remember of can use \ncmd + return\n or \nctrl + return\n to stop and fully reinitialize the scenario).\n\n\nAdjusting events in time\n\n\nWe saw that moving events along allows to adjust events' position on the timeline. But a few important points are worth to be added to the topic. One of Score's strength resides in some advanced features to control time flow in a highly precise way. This is especially useful as your scenario grows and as the various media dealt with your device (sound generation or processing, video, lights) induces complex temporal relationship between events.\n\n\nIf you select the last state you stored in your scenario, you can move it on the timeline as previously done. Now select a state in the middle of a sequence of events and see what happens: Score will preserve the length of the interval to the following event and \nmove\n all following events in your scenario subsequently. This is extremely useful when wanting to adjusting things locally (ie. Parts of a scene of a theatre piece while rehearsing ) while maintaining the rest of the structure untouched.\n\n\n\n\nYou may also adjust time between events with a particular length (ie. The time it takes for some curtains to get drawn on stage). To do so, select an interval by clicking on it in the timeline, then from its inspector, type the desired length.\n\n\n\n\nThere are some times when you may want to move some event without moving all following events, though. This can be done by moving things around using the \nlock mode\n. To do so, click on the lock button in the toolbar and move the selected event on the timeline (or select an event to move while holding the \noption\n key on macOS or \nalt\n key on Windows).\n\n\n\n\nWriting processes\n\n\nNow that we covered the basis of Score workflow, we may add a little more animation to our scenario using a few of the many processes provided in Score.\n\n\nProcesses are different widgets allowing to control some parameter's value over a given amount of time (the length given by an interval drawn in the scenario). Let start by adding a gentle fade in in our scenario. To do so, we will add an automation on our 'gain' parameter. From the Device explorer, select the 'gain' parameter and let's drag \n drop it over the interval linking the first and second states on the timeline (that is, the one containing the 'start' message and the one raising the 'gain' to 0 dB , etc.). Score automatically creates a break-point function automation.\n\n\n\n\nYou may fine-tune your break-point function and more points by double-clicking in the automation background, move points by selecting points then move them around or add curve using \nshift + drag\n on a segment.\n\n\nThere are various types of functions for the automation process. We will add a little more fun to our scenario using another one of these.\n\n\nIn this second example, we want to create an automation following the last state of our device that we store in the scenario. Since there is no interval already in place, we first need to create one so we can attach a process to it. To do so, select the last stored state in our scenario. You can see that a little yellow '+' sign popup next to the event. \nclick + drag\n on the plus sign to draw an interval in the scenario of a desired length, then release your mouse. We thus created an interval (without storing state at its right end).\n\n\n\n\nWe may now drag the parameter to automate as we previously did. Although, while dragging and dropping parameters is a handy shortcut, there are situations (when using generator processes) where we cannot benefit from these so we will go through the whole process by hand.\n\n\nClick on the interval we just created to bring a little '+' sign attached to the interval. Click that '+' sign to open up the processes library. The window displays different banks each containing various processes. From the 'automations' bank, choose 'automation (float)'. Double-click (or click the '+' button) then close the window. We now created an automation.\n\n\n\n\nWe first have to set the name of the parameter we want to automate. Click on the automation header (displaying \"Automation\" as a greyed out label) to bring its inspector. From the Device explorer, select the parameter to automate (ie 'modulation/ratio') and drag it over to 'Address' field the automation inspector. The automation will now use this parameter as destination. \n\n\nThe automation process offers a number of embedded function (standard easing functions, waveforms, etc.). Hence, rather than adding points and curve, here we will use the noise generator. In the automation box, select the red segment then right-click. From the function contextual menu, navigate through the 'Automation (float) \n Type' section then choose 'noise'. Score now filled our automation process with a random function.\n\n\n\n\nOne more thing we may want to do before listening to our composition. When doing automation, Score use by default the min/max values of the automated parameter. Here, we will adjust these bounds so the automation runs in a user-defined range.\n\n\nFrom the automation inspector, check the min and max textfield and set desired values. We will arbitrary use a minimum value of 5 and maximum value of 9. But feel free to experiment and adjust to your taste!\n\n\nSummary\n\n\nWe now covered the major features of the Score workflow: setting up your devices network, storing \n recalling snapshots, writing automations for the parameters of your device, write precise temporal structure.\n\n\nScore offers a number of other features depending on the protocols used to communicate with your devices, handy shortcuts to ease the writing of complex performances or installations, vast collection of available processes that will get covered in the following on the documentation.\n\n\nIn the mean time, this should get you the needed basis to start with Score scenario authoring.\n\n\nYou may now sit comfortably, relax and enjoy your composition. Or just start experimenting !", 
            "title": "Writing your first scenario"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#writing-your-first-score-scenario", 
            "text": "In this short tutorial, we will write a simple scenario in Score. This should provide the basis to get familiar with Score interface and general workflow.  Here we will use a simple frequency modulation-based synthesizer provided with Score documentation. Assuming you already have Pd or Max installed on you computer, you may use the Pd or Max version of this patch.   If frequency modulation synthesis does not sounds like fun to you, you may follow this tutorial using your favorite Open Sound Control (OSC) application. In that case, just follow the various steps and adjust the various options (OSC configuration, namespace configuration, etc.) to your application.   Since we will use Score to control a distant application, we first need to setup our OSC device in Score so they can communicate properly.", 
            "title": "Writing your first Score scenario"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#adding-your-device", 
            "text": "Once launched, Score opens with an empty window. To setup our OSC device, click the  +  button at the bottom left of the  Device explorer  pane or use  cmd + B  (on MacOS) /  ctrl + B  (on Windows) shortcut. This prompts a configuration window where we can setup various protocols informations.   The configuration window provides a list of all protocols supported in Score. Here we will select OSC from the menu. This bring the various option fields needed to setup the communication between our application and Score:   A name for the device (used for display only)  The network port your application will receive OSC messages from  The network port Score will receive OSC messages from (assuming your application can echo back its parameters current state)  IP address of the computer of your application is running on.   Our simple patch example is built to use Score's OSC default ports and address so you can leave the above fields untouched. Then click the  load  button to load the  fm-osc-example.device  namespace file of our device. Press the  return  key or click the  OK  button. The Device explorer should now display our device named  OSCdevice  along with all its parameters and various attributes settings in a tree-like view.   Should you need to modify the OSC setup of your device, right-click on your device name in the Device explorer pane and choose  Edit .   The namespace file we just loaded is a json file describing all parameters addresses of a device we want to send values to. If using another OSC application for this tutorial, you may either use the learn feature available when right-clicking your device name in the Device explorer, or manually declare the namespace of your application. In the later case, please see the  How to manually declare a namespace  documentation page.", 
            "title": "Adding your device"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#setting-an-initial-state", 
            "text": "We will start by setting an  init  state for our scenario. In this case, the default state of our device will be perfect as an init state so we will just store its parameters current value in the scenario initial event.  The easiest way to do this is to select the parameter to store from the Device explorer pane then drag them on the scenario initial event. Selection can be done using regular mouse   key combos. Hence we can select the 'pan' parameter then  shift + click  on the 'frequency' parameter to select both these addresses and all between them in the tree view. For the sake of this tutorial, we will also make sure that DSP processing is turned off by default in Pd. With the current selected addresses, cmd + click (on MacOS) or ctrl + click (on Windows) on the 'stop' parameter then drag this full selection on the initial event as shown below.    Note that selecting a node containing parameters in the namespace will select all parameters below it (ie. clicking 'modulation' selects both 'modulation/index'   'modulation/ratio')    When done, you can see that the scenario initial event (the blue dot on the scenario timeline) is now displayed with a surrounding white circle. If you click on the state we just created, you can see in the inspector all the stored values and their associated value.   Having set this init state, now when reinitializing the scenario (using  cmd + return  on macOS or  ctrl + return  on Windows), Score will automatically recall our device's state so it is ready to go !", 
            "title": "Setting an initial state"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#storing-states-of-your-device", 
            "text": "We will now store more states in our scenario and organize them on the timeline.  We will start with a simple state used to turn Pd's DSP processing on. As we previously did, let's grab the 'start' parameter and drop it on Score timeline. As you are hovering the timeline with the 'start' parameter, notice that a grey dashed line connected to the first event on the scenario is drawn.  Remember that events and processes needed to connected to a time source  so they get properly executed as time progress in the scenario. By default, Score then offers to automatically connect events sequentially.   Again, if you select the created state, you can see in its inspector that the 'start' parameter has been saved.  You can select this event and move it around on the timeline. Moving it horizontally lets you adjust its position on the timeline (hence when the stored parameters will get sent when playing the scenario). Vertical position has no but graphical purpose for the execution of our scenario. We can now store more states.  The device used in this tutorial only provides unidirectional communication (our device can only receive message from Score) so we will use the device explorer as a simple remote interface. To do so, just double-click on the value fields you want to change and type the desired value. We will for example raise the gain up to 0 dB, set the 'modulation/index' to 100 and set the 'ramptime' to 20 ms.You may now store this new state just as we did above.   When using bidirectional protocol between Score and your device (ie. OSCquery), Score will listen to the parameters changes in the device. You may then make changes right from your device or using your favorites controllers (hence avoid fastidiously typing values by hand)   Select the addresses you want to store then drag them on the timeline. You will see that Score offers to connect this new event to the event it is most aligned with. Make sure to connect this new event to the one we previously created.  Now follow your inspiration and store on the timeline as many of your device's states or  fine tune them  as you wish.   Press the  spacebar  to start playing our scenario and recalling these snapshots as time moves along the timeline. You may pause the execution of our scenario pressing the  spacebar  again or stop it using  return  key (remember of can use  cmd + return  or  ctrl + return  to stop and fully reinitialize the scenario).", 
            "title": "Storing states of your device"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#adjusting-events-in-time", 
            "text": "We saw that moving events along allows to adjust events' position on the timeline. But a few important points are worth to be added to the topic. One of Score's strength resides in some advanced features to control time flow in a highly precise way. This is especially useful as your scenario grows and as the various media dealt with your device (sound generation or processing, video, lights) induces complex temporal relationship between events.  If you select the last state you stored in your scenario, you can move it on the timeline as previously done. Now select a state in the middle of a sequence of events and see what happens: Score will preserve the length of the interval to the following event and  move  all following events in your scenario subsequently. This is extremely useful when wanting to adjusting things locally (ie. Parts of a scene of a theatre piece while rehearsing ) while maintaining the rest of the structure untouched.   You may also adjust time between events with a particular length (ie. The time it takes for some curtains to get drawn on stage). To do so, select an interval by clicking on it in the timeline, then from its inspector, type the desired length.   There are some times when you may want to move some event without moving all following events, though. This can be done by moving things around using the  lock mode . To do so, click on the lock button in the toolbar and move the selected event on the timeline (or select an event to move while holding the  option  key on macOS or  alt  key on Windows).", 
            "title": "Adjusting events in time"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#writing-processes", 
            "text": "Now that we covered the basis of Score workflow, we may add a little more animation to our scenario using a few of the many processes provided in Score.  Processes are different widgets allowing to control some parameter's value over a given amount of time (the length given by an interval drawn in the scenario). Let start by adding a gentle fade in in our scenario. To do so, we will add an automation on our 'gain' parameter. From the Device explorer, select the 'gain' parameter and let's drag   drop it over the interval linking the first and second states on the timeline (that is, the one containing the 'start' message and the one raising the 'gain' to 0 dB , etc.). Score automatically creates a break-point function automation.   You may fine-tune your break-point function and more points by double-clicking in the automation background, move points by selecting points then move them around or add curve using  shift + drag  on a segment.  There are various types of functions for the automation process. We will add a little more fun to our scenario using another one of these.  In this second example, we want to create an automation following the last state of our device that we store in the scenario. Since there is no interval already in place, we first need to create one so we can attach a process to it. To do so, select the last stored state in our scenario. You can see that a little yellow '+' sign popup next to the event.  click + drag  on the plus sign to draw an interval in the scenario of a desired length, then release your mouse. We thus created an interval (without storing state at its right end).   We may now drag the parameter to automate as we previously did. Although, while dragging and dropping parameters is a handy shortcut, there are situations (when using generator processes) where we cannot benefit from these so we will go through the whole process by hand.  Click on the interval we just created to bring a little '+' sign attached to the interval. Click that '+' sign to open up the processes library. The window displays different banks each containing various processes. From the 'automations' bank, choose 'automation (float)'. Double-click (or click the '+' button) then close the window. We now created an automation.   We first have to set the name of the parameter we want to automate. Click on the automation header (displaying \"Automation\" as a greyed out label) to bring its inspector. From the Device explorer, select the parameter to automate (ie 'modulation/ratio') and drag it over to 'Address' field the automation inspector. The automation will now use this parameter as destination.   The automation process offers a number of embedded function (standard easing functions, waveforms, etc.). Hence, rather than adding points and curve, here we will use the noise generator. In the automation box, select the red segment then right-click. From the function contextual menu, navigate through the 'Automation (float)   Type' section then choose 'noise'. Score now filled our automation process with a random function.   One more thing we may want to do before listening to our composition. When doing automation, Score use by default the min/max values of the automated parameter. Here, we will adjust these bounds so the automation runs in a user-defined range.  From the automation inspector, check the min and max textfield and set desired values. We will arbitrary use a minimum value of 5 and maximum value of 9. But feel free to experiment and adjust to your taste!", 
            "title": "Writing processes"
        }, 
        {
            "location": "/first_steps/first_scenario/index.html#summary", 
            "text": "We now covered the major features of the Score workflow: setting up your devices network, storing   recalling snapshots, writing automations for the parameters of your device, write precise temporal structure.  Score offers a number of other features depending on the protocols used to communicate with your devices, handy shortcuts to ease the writing of complex performances or installations, vast collection of available processes that will get covered in the following on the documentation.  In the mean time, this should get you the needed basis to start with Score scenario authoring.  You may now sit comfortably, relax and enjoy your composition. Or just start experimenting !", 
            "title": "Summary"
        }, 
        {
            "location": "/howtos/declare_an_osc_device/index.html", 
            "text": "How to setup an OSC device ?\n\n\nTo setup an Open Sound Control compatible device to be used with Score, click the \n+\n button at the bottom left of the \nDevice explorer\n pane or use \ncmd + B\n (on MacOS) / \nctrl + B\n (on Windows) shortcut. This prompts a configuration window where we can setup various protocols informations.\n\n\n\n\nFrom the \nProtocol\n menu, select OSC. This brings the various option fields needed to setup the communication between your application and Score:\n\n\n\n\nA name for the device (used for display only)\n\n\nThe network port your application will receive OSC messages from\n\n\nThe network port Score will receive OSC messages from (assuming your application can echo back its parameters current state)\n\n\nIP address of the computer of your application is running on.\n\n\n\n\n\n\nThese setup up the communication between Score and your application.\n\n\n\n\nThe setup of your OSC device can be adjusted at any time, by right-clicking on your device name in the Device explorer pane and choose \nEdit\n from the contextual menu.\n\n\n\n\nWhen done, you may either:\n\n\n\n\nLoad a namespace file from the device setup window that describes all the parameters of your application\n\n\nUse the \nlearn\n function available when \nright-clicking your device name in the Device explorer\n\n\nManually declare the namespace in the Device explorer pane", 
            "title": "Setup an OSC device"
        }, 
        {
            "location": "/howtos/declare_an_osc_device/index.html#how-to-setup-an-osc-device", 
            "text": "To setup an Open Sound Control compatible device to be used with Score, click the  +  button at the bottom left of the  Device explorer  pane or use  cmd + B  (on MacOS) /  ctrl + B  (on Windows) shortcut. This prompts a configuration window where we can setup various protocols informations.   From the  Protocol  menu, select OSC. This brings the various option fields needed to setup the communication between your application and Score:   A name for the device (used for display only)  The network port your application will receive OSC messages from  The network port Score will receive OSC messages from (assuming your application can echo back its parameters current state)  IP address of the computer of your application is running on.    These setup up the communication between Score and your application.   The setup of your OSC device can be adjusted at any time, by right-clicking on your device name in the Device explorer pane and choose  Edit  from the contextual menu.   When done, you may either:   Load a namespace file from the device setup window that describes all the parameters of your application  Use the  learn  function available when  right-clicking your device name in the Device explorer  Manually declare the namespace in the Device explorer pane", 
            "title": "How to setup an OSC device ?"
        }, 
        {
            "location": "/howtos/manual_namespace_setup/index.html", 
            "text": "How to manually declare a namespace ?\n\n\nWhen not using Score with an application providing querying mechanism (such as OSCQuery) or echoing its parameters state, you need to manually add the parameter addresses to your device setup. Once having \nsetup an OSC device\n, click on the device name and from the contextual menu, choose \nAdd child\n to add an address at a level below. (you may as well choose \nAdd sibling\n when right-clicking on a parameter name to add a parameter at the same hierarchical level)\n\n\n\n\nThis brings a configuration window for the parameter to declare in the namespace.\n\n\nScore (along with some compatible protocols such as OSCQuery or Minuit) offers a number of attributes describing a parameter behaviour. Setting up these attributes allows to benefit from a number of Score handy features such as automatic value range setup when writing automations, repetitions filtering or unit conversion, to name a few.\n\n\n\n\nThese attributes are the following:\n\n\n\n\nParameter name\n\n\nType of value\n\n\nDefault value\n\n\nDomain (range)\n\n\nClip mode\n\n\nI/O type\n\n\nRepetitions filter\n\n\nOptional tags\n\n\nUnit\n\n\nDescription\n\n\n\n\nPlease see \nlibossia documentation page\n for detailed explanation on these attributes.\n\n\nJust fill these various optional attributes for the parameter to declare then click the \nOk\n button. Freshly created parameter now appears in the Device explorer.\n\n\n\n\nNote that at the time of this writing, it is not possible to add in one go a parameter under several nodes (ie. \n/foo/bar/my_parameter\n). For the time being, you need to add the various nodes one at each time and set \ncontainer\n as type. Then right-click on the created node and select \nAdd child\n as many times as needed.\n\n\n\n\nSaving namespace as a file\n\n\nWhen done adding the various parameters of your device, you can save the resulting namespace as a file for later use. Hence when working with this device in another project, you will be able to import the namespace when setting up the device and avoid the tedious manual namespace declaration above.\n\n\nTo do so, right-click on your device name, then from the contextual menu, choose \nExport device\n.", 
            "title": "Manually declare a namespace"
        }, 
        {
            "location": "/howtos/manual_namespace_setup/index.html#how-to-manually-declare-a-namespace", 
            "text": "When not using Score with an application providing querying mechanism (such as OSCQuery) or echoing its parameters state, you need to manually add the parameter addresses to your device setup. Once having  setup an OSC device , click on the device name and from the contextual menu, choose  Add child  to add an address at a level below. (you may as well choose  Add sibling  when right-clicking on a parameter name to add a parameter at the same hierarchical level)   This brings a configuration window for the parameter to declare in the namespace.  Score (along with some compatible protocols such as OSCQuery or Minuit) offers a number of attributes describing a parameter behaviour. Setting up these attributes allows to benefit from a number of Score handy features such as automatic value range setup when writing automations, repetitions filtering or unit conversion, to name a few.   These attributes are the following:   Parameter name  Type of value  Default value  Domain (range)  Clip mode  I/O type  Repetitions filter  Optional tags  Unit  Description   Please see  libossia documentation page  for detailed explanation on these attributes.  Just fill these various optional attributes for the parameter to declare then click the  Ok  button. Freshly created parameter now appears in the Device explorer.   Note that at the time of this writing, it is not possible to add in one go a parameter under several nodes (ie.  /foo/bar/my_parameter ). For the time being, you need to add the various nodes one at each time and set  container  as type. Then right-click on the created node and select  Add child  as many times as needed.", 
            "title": "How to manually declare a namespace ?"
        }, 
        {
            "location": "/howtos/manual_namespace_setup/index.html#saving-namespace-as-a-file", 
            "text": "When done adding the various parameters of your device, you can save the resulting namespace as a file for later use. Hence when working with this device in another project, you will be able to import the namespace when setting up the device and avoid the tedious manual namespace declaration above.  To do so, right-click on your device name, then from the contextual menu, choose  Export device .", 
            "title": "Saving namespace as a file"
        }, 
        {
            "location": "/howtos/namespace_learning/index.html", 
            "text": "How to use the learn function to build your application namespace ?\n\n\nOnce having \nsetup an OSC device\n, you may want to use the Device explorer's learn feature to ease the declaration of all the parameter addresses of the application you want to control from Score. To do so, in the Device explorer, right-click on your device name then from the contextual menu, choose \nlearn\n.\n\n\n\n\nThis brings a popup window displaying learnt parameters address. Assuming echoing of the parameters value is properly setup in your distant application, you may now start changing their value (ie. From the GUI) so they get sent back to Score. These should appear in Score's \nOSC learning\n window. \n\n\n\n\nWhen done in your distant application, press the \nreturn\n key or click the \nOk\n button.\n\n\nThe Device explorer should now display all parameters from your device as a tree-like view.\n\n\nEditing parameters attributes\n\n\nUsing the learn function only set the namespace structure of your distant application. You may want to specify these parameters in order to benefit from Score parameter attributes-dependant features (ie. Automatic value range setup when writing automations, repetitions filtering, unit conversion).\n\n\nTo do so, in the Device explorer right-click on a parameter name of your device, then choose \nEdit\n. This bring a configuration window allowing to edit various attributes describing a parameter behaviour.\n\n\n\n\nThe attributes are the following:\n\n\n\n\nParameter name\n\n\nType of value\n\n\nDefault value\n\n\nDomain (range)\n\n\nClip mode\n\n\nI/O type\n\n\nRepetitions filter\n\n\nOptional tags\n\n\nUnit\n\n\nDescription\n\n\n\n\nPlease see \nlibossia documentation page\n for detailed explanation on these attributes.", 
            "title": "Use the learn function"
        }, 
        {
            "location": "/howtos/namespace_learning/index.html#how-to-use-the-learn-function-to-build-your-application-namespace", 
            "text": "Once having  setup an OSC device , you may want to use the Device explorer's learn feature to ease the declaration of all the parameter addresses of the application you want to control from Score. To do so, in the Device explorer, right-click on your device name then from the contextual menu, choose  learn .   This brings a popup window displaying learnt parameters address. Assuming echoing of the parameters value is properly setup in your distant application, you may now start changing their value (ie. From the GUI) so they get sent back to Score. These should appear in Score's  OSC learning  window.    When done in your distant application, press the  return  key or click the  Ok  button.  The Device explorer should now display all parameters from your device as a tree-like view.", 
            "title": "How to use the learn function to build your application namespace ?"
        }, 
        {
            "location": "/howtos/namespace_learning/index.html#editing-parameters-attributes", 
            "text": "Using the learn function only set the namespace structure of your distant application. You may want to specify these parameters in order to benefit from Score parameter attributes-dependant features (ie. Automatic value range setup when writing automations, repetitions filtering, unit conversion).  To do so, in the Device explorer right-click on a parameter name of your device, then choose  Edit . This bring a configuration window allowing to edit various attributes describing a parameter behaviour.   The attributes are the following:   Parameter name  Type of value  Default value  Domain (range)  Clip mode  I/O type  Repetitions filter  Optional tags  Unit  Description   Please see  libossia documentation page  for detailed explanation on these attributes.", 
            "title": "Editing parameters attributes"
        }, 
        {
            "location": "/howtos/update_state/index.html", 
            "text": "How to update parameters value\n\n\nUsing the refresh function\n\n\nWhen using Score with a device providing bidirectional protocol such as OSCquery, Score listens to parameters changes in the controlled device. Stored states can then be updated by selecting the state to update on the timeline and click the 'Refresh state' button in the toolbar or use \ncmd + u\n on macOS or \nctrl + u\n on Windows.\n\n\nIf your device can only receive messages from Score, in the Device explorer, double-click on a parameter's value textfield and type the desired value. Now lick the 'Refresh state' button in the toolbar or use \ncmd + u\n on macOS or \nctrl + u\n on Windows.\n\n\n\n\nUsing the inspector\n\n\nAlternatively, stored states can be edited from a state inspector.\n\n\nOn the timeline, select the state to edit to display its inspector. From the tree view of the stored addresses and value, double-click on the value textfield and type the desired value.", 
            "title": "Update stored state"
        }, 
        {
            "location": "/howtos/update_state/index.html#how-to-update-parameters-value", 
            "text": "", 
            "title": "How to update parameters value"
        }, 
        {
            "location": "/howtos/update_state/index.html#using-the-refresh-function", 
            "text": "When using Score with a device providing bidirectional protocol such as OSCquery, Score listens to parameters changes in the controlled device. Stored states can then be updated by selecting the state to update on the timeline and click the 'Refresh state' button in the toolbar or use  cmd + u  on macOS or  ctrl + u  on Windows.  If your device can only receive messages from Score, in the Device explorer, double-click on a parameter's value textfield and type the desired value. Now lick the 'Refresh state' button in the toolbar or use  cmd + u  on macOS or  ctrl + u  on Windows.", 
            "title": "Using the refresh function"
        }, 
        {
            "location": "/howtos/update_state/index.html#using-the-inspector", 
            "text": "Alternatively, stored states can be edited from a state inspector.  On the timeline, select the state to edit to display its inspector. From the tree view of the stored addresses and value, double-click on the value textfield and type the desired value.", 
            "title": "Using the inspector"
        }
    ]
}